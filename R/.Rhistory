#Cbind returns, id, time and predictors
panel <- cbind(rt_cross_tune_df$return, rt_cross_tune_df$resid, c(1:(Time+1)), c(rep(i, (Time+1))))
rt_cross_tune_panel[((i-1)*(Time+1)+1):(i*(Time+1)), ] <- panel
}
#Sort by time
rt_cross_tune_panel <- rt_cross_tune_panel %>%
arrange(time)
#Remove 1st row because returns data only starts from t = 2
rt_cross_tune_panel <- rt_cross_tune_panel %>%
filter(time != 1) %>%
select(-time)
#Individual return R squared
rt_id_tune_df <- data.frame(
stock = c(1:200),
rsquare = c(1:200)
)
for (i in 1:N) {
rt_id_tune_panel <- rt_cross_tune_panel %>%
filter(stock == i)
SSR <- t(rt_id_tune_panel$resid) %*% rt_id_tune_panel$resid
SST <- t(rt_id_tune_panel$return - mean(rt_id_tune_panel$return)) %*% (rt_id_tune_panel$return - mean(rt_id_tune_panel$return))
#SST <- t(rt_id_tune_panel$return) %*% (rt_id_tune_panel$return)
rt_id_tune_df$rsquare[i] <- 1 - SSR/SST
}
#Return mean of each individual rsquared
mean(rt_id_tune_df$rsquare)
#Calculate Annualized Volatility
#Annualized volatility = calculate volatility (via standard deviation) for the monthly returns, then annualize it by multiplying it by sqrt(12) for 12 months in a year
vol_tune_df <- data.frame(
stock = c(1:200),
annual_vol = c(1:200)
)
for (i in 1:200) {
vol_tune_panel <- rt_cross_tune_panel %>%
filter(stock == i)
vol_tune_df$annual_vol[i] <- sd(vol_tune_panel$return) * sqrt(12)
}
#Return the mean annualized volatility
#Want this aorund 30%
mean(vol_tune_df$annual_vol)
#Cross sectional r squared
SSR <- t(rt_cross_tune_panel$resid) %*% (rt_cross_tune_panel$resid)
#SST <- t(rt_cross_tune_panel$return - mean(rt_cross_tune_panel$return)) %*% (rt_cross_tune_panel$return - mean(rt_cross_tune_panel$return))
SST <- t(rt_cross_tune_panel$return) %*% (rt_cross_tune_panel$return)
1 - SSR/SST
#This is quite off from Gu et al's specification and results. NOT GOOD
ggplot(rt) +
geom_line
#Tuning Cross Sectional R Squared SKELETON CODE
#We want inidividual r squared for each stock to be 50%
#We want inidividual annualized volatility to be 30%
#We want to cross sectional R squared to be 25%
#We want the predictive R squared to be 5%
#Generate paramaters first
#Tune v_sd for inidividual r square first
#Gu et al had 0.05 for their v sd
v_sd <- 0.05
ep_sd <- 0.05
resid <- gu_gen_rt_resid(v_sd, ep_sd)
#Tune theta for cross sectional r square
#theta
theta <- matrix(c(0.02, 0.02, 0.02), nrow = 1)
rt <- gu_gen_rt(g1, resid)
rt_cross_tune_panel <- data.frame(
return = rep(0, 36000),
resid = rep(0, 36000),
time = rep(0, 36000),
stock = rep(0, 36000)
)
for (i in 1:N){
rt_cross_tune_df <- data.frame(
return = rep(0, Time+1),
resid = rep(0, Time+1),
time = rep(0, Time+1)
)
for (t in 1:(Time+1)){
rt_cross_tune_df$return[t] <- rt[[t]][i]
rt_cross_tune_df$resid[t] <- resid[[t]][i]
}
#Cbind returns, id, time and predictors
panel <- cbind(rt_cross_tune_df$return, rt_cross_tune_df$resid, c(1:(Time+1)), c(rep(i, (Time+1))))
rt_cross_tune_panel[((i-1)*(Time+1)+1):(i*(Time+1)), ] <- panel
}
#Sort by time
rt_cross_tune_panel <- rt_cross_tune_panel %>%
arrange(time)
#Remove 1st row because returns data only starts from t = 2
rt_cross_tune_panel <- rt_cross_tune_panel %>%
filter(time != 1) %>%
select(-time)
#Individual return R squared
rt_id_tune_df <- data.frame(
stock = c(1:200),
rsquare = c(1:200)
)
for (i in 1:N) {
rt_id_tune_panel <- rt_cross_tune_panel %>%
filter(stock == i)
SSR <- t(rt_id_tune_panel$resid) %*% rt_id_tune_panel$resid
#SST <- t(rt_id_tune_panel$return - mean(rt_id_tune_panel$return)) %*% (rt_id_tune_panel$return - mean(rt_id_tune_panel$return))
SST <- t(rt_id_tune_panel$return) %*% (rt_id_tune_panel$return)
rt_id_tune_df$rsquare[i] <- 1 - SSR/SST
}
#Return mean of each individual rsquared
mean(rt_id_tune_df$rsquare)
#Calculate Annualized Volatility
#Annualized volatility = calculate volatility (via standard deviation) for the monthly returns, then annualize it by multiplying it by sqrt(12) for 12 months in a year
vol_tune_df <- data.frame(
stock = c(1:200),
annual_vol = c(1:200)
)
for (i in 1:200) {
vol_tune_panel <- rt_cross_tune_panel %>%
filter(stock == i)
vol_tune_df$annual_vol[i] <- sd(vol_tune_panel$return) * sqrt(12)
}
#Return the mean annualized volatility
#Want this aorund 30%
mean(vol_tune_df$annual_vol)
#Cross sectional r squared
SSR <- t(rt_cross_tune_panel$resid) %*% (rt_cross_tune_panel$resid)
#SST <- t(rt_cross_tune_panel$return - mean(rt_cross_tune_panel$return)) %*% (rt_cross_tune_panel$return - mean(rt_cross_tune_panel$return))
SST <- t(rt_cross_tune_panel$return) %*% (rt_cross_tune_panel$return)
1 - SSR/SST
#This is quite off from Gu et al's specification and results. NOT GOOD
ggplot(rt) +
geom_line
#Tuning Cross Sectional R Squared SKELETON CODE
#We want inidividual r squared for each stock to be 50%
#We want inidividual annualized volatility to be 30%
#We want to cross sectional R squared to be 25%
#We want the predictive R squared to be 5%
#Generate paramaters first
#Tune v_sd for inidividual r square first
#Gu et al had 0.05 for their v sd
v_sd <- 0.05
ep_sd <- 0.05
resid <- gu_gen_rt_resid(v_sd, ep_sd)
#Tune theta for cross sectional r square
#theta
theta <- matrix(c(0.02, 0.02, 0.02), nrow = 1)
rt <- gu_gen_rt(g1, resid)
rt_cross_tune_panel <- data.frame(
return = rep(0, 36000),
resid = rep(0, 36000),
time = rep(0, 36000),
stock = rep(0, 36000)
)
for (i in 1:N){
rt_cross_tune_df <- data.frame(
return = rep(0, Time+1),
resid = rep(0, Time+1),
time = rep(0, Time+1)
)
for (t in 1:(Time+1)){
rt_cross_tune_df$return[t] <- rt[[t]][i]
rt_cross_tune_df$resid[t] <- resid[[t]][i]
}
#Cbind returns, id, time and predictors
panel <- cbind(rt_cross_tune_df$return, rt_cross_tune_df$resid, c(1:(Time+1)), c(rep(i, (Time+1))))
rt_cross_tune_panel[((i-1)*(Time+1)+1):(i*(Time+1)), ] <- panel
}
#Sort by time
rt_cross_tune_panel <- rt_cross_tune_panel %>%
arrange(time)
#Remove 1st row because returns data only starts from t = 2
rt_cross_tune_panel <- rt_cross_tune_panel %>%
filter(time != 1) %>%
select(-time)
#Individual return R squared
rt_id_tune_df <- data.frame(
stock = c(1:200),
rsquare = c(1:200)
)
for (i in 1:N) {
rt_id_tune_panel <- rt_cross_tune_panel %>%
filter(stock == i)
SSR <- t(rt_id_tune_panel$resid) %*% rt_id_tune_panel$resid
#SST <- t(rt_id_tune_panel$return - mean(rt_id_tune_panel$return)) %*% (rt_id_tune_panel$return - mean(rt_id_tune_panel$return))
SST <- t(rt_id_tune_panel$return) %*% (rt_id_tune_panel$return)
rt_id_tune_df$rsquare[i] <- 1 - SSR/SST
}
#Return mean of each individual rsquared
mean(rt_id_tune_df$rsquare)
#Calculate Annualized Volatility
#Annualized volatility = calculate volatility (via standard deviation) for the monthly returns, then annualize it by multiplying it by sqrt(12) for 12 months in a year
vol_tune_df <- data.frame(
stock = c(1:200),
annual_vol = c(1:200)
)
for (i in 1:200) {
vol_tune_panel <- rt_cross_tune_panel %>%
filter(stock == i)
vol_tune_df$annual_vol[i] <- sd(vol_tune_panel$return) * sqrt(12)
}
#Return the mean annualized volatility
#Want this aorund 30%
mean(vol_tune_df$annual_vol)
#Cross sectional r squared
SSR <- t(rt_cross_tune_panel$resid) %*% (rt_cross_tune_panel$resid)
#SST <- t(rt_cross_tune_panel$return - mean(rt_cross_tune_panel$return)) %*% (rt_cross_tune_panel$return - mean(rt_cross_tune_panel$return))
SST <- t(rt_cross_tune_panel$return) %*% (rt_cross_tune_panel$return)
1 - SSR/SST
#This is quite off from Gu et al's specification and results. NOT GOOD
#Tuning Cross Sectional R Squared SKELETON CODE
#We want inidividual r squared for each stock to be 50%
#We want inidividual annualized volatility to be 30%
#We want to cross sectional R squared to be 25%
#We want the predictive R squared to be 5%
#Generate paramaters first
#Tune v_sd for inidividual r square first
#Gu et al had 0.05 for their v sd
v_sd <- 0.05
ep_sd <- 0.05
resid <- gu_gen_rt_resid(v_sd, ep_sd)
#Tune theta for cross sectional r square
#theta
theta <- matrix(c(0.02, 0.02, 0.02), nrow = 1)
rt <- gu_gen_rt(g1, resid)
rt_cross_tune_panel <- data.frame(
return = rep(0, 36000),
resid = rep(0, 36000),
time = rep(0, 36000),
stock = rep(0, 36000)
)
for (i in 1:N){
rt_cross_tune_df <- data.frame(
return = rep(0, Time+1),
resid = rep(0, Time+1),
time = rep(0, Time+1)
)
for (t in 1:(Time+1)){
rt_cross_tune_df$return[t] <- rt[[t]][i]
rt_cross_tune_df$resid[t] <- resid[[t]][i]
}
#Cbind returns, id, time and predictors
panel <- cbind(rt_cross_tune_df$return, rt_cross_tune_df$resid, c(1:(Time+1)), c(rep(i, (Time+1))))
rt_cross_tune_panel[((i-1)*(Time+1)+1):(i*(Time+1)), ] <- panel
}
#Sort by time
rt_cross_tune_panel <- rt_cross_tune_panel %>%
arrange(time)
#Remove 1st row because returns data only starts from t = 2
rt_cross_tune_panel <- rt_cross_tune_panel %>%
filter(time != 1) %>%
select(-time)
#Individual return R squared
rt_id_tune_df <- data.frame(
stock = c(1:200),
rsquare = c(1:200)
)
for (i in 1:N) {
rt_id_tune_panel <- rt_cross_tune_panel %>%
filter(stock == i)
SSR <- t(rt_id_tune_panel$resid) %*% rt_id_tune_panel$resid
#SST <- t(rt_id_tune_panel$return - mean(rt_id_tune_panel$return)) %*% (rt_id_tune_panel$return - mean(rt_id_tune_panel$return))
SST <- t(rt_id_tune_panel$return) %*% (rt_id_tune_panel$return)
rt_id_tune_df$rsquare[i] <- 1 - SSR/SST
}
#Return mean of each individual rsquared
mean(rt_id_tune_df$rsquare)
#Calculate Annualized Volatility
#Annualized volatility = calculate volatility (via standard deviation) for the monthly returns, then annualize it by multiplying it by sqrt(12) for 12 months in a year
vol_tune_df <- data.frame(
stock = c(1:200),
annual_vol = c(1:200)
)
for (i in 1:200) {
vol_tune_panel <- rt_cross_tune_panel %>%
filter(stock == i)
vol_tune_df$annual_vol[i] <- sd(vol_tune_panel$return) * sqrt(12)
}
#Return the mean annualized volatility
#Want this aorund 30%
mean(vol_tune_df$annual_vol)
#Cross sectional r squared
SSR <- t(rt_cross_tune_panel$resid) %*% (rt_cross_tune_panel$resid)
#SST <- t(rt_cross_tune_panel$return - mean(rt_cross_tune_panel$return)) %*% (rt_cross_tune_panel$return - mean(rt_cross_tune_panel$return))
SST <- t(rt_cross_tune_panel$return) %*% (rt_cross_tune_panel$return)
1 - SSR/SST
#This is quite off from Gu et al's specification and results. NOT GOOD
#Tuning Cross Sectional R Squared SKELETON CODE
#We want inidividual r squared for each stock to be 50%
#We want inidividual annualized volatility to be 30%
#We want to cross sectional R squared to be 25%
#We want the predictive R squared to be 5%
#Generate paramaters first
#Tune v_sd for inidividual r square first
#Gu et al had 0.05 for their v sd
v_sd <- 0.05
ep_sd <- 0.05
resid <- gu_gen_rt_resid(v_sd, ep_sd)
#Tune theta for cross sectional r square
#theta
theta <- matrix(c(0.02, 0.02, 0.02), nrow = 1)
rt <- gu_gen_rt(g1, resid)
rt_cross_tune_panel <- data.frame(
return = rep(0, 36000),
resid = rep(0, 36000),
time = rep(0, 36000),
stock = rep(0, 36000)
)
for (i in 1:N){
rt_cross_tune_df <- data.frame(
return = rep(0, Time+1),
resid = rep(0, Time+1),
time = rep(0, Time+1)
)
for (t in 1:(Time+1)){
rt_cross_tune_df$return[t] <- rt[[t]][i]
rt_cross_tune_df$resid[t] <- resid[[t]][i]
}
#Cbind returns, id, time and predictors
panel <- cbind(rt_cross_tune_df$return, rt_cross_tune_df$resid, c(1:(Time+1)), c(rep(i, (Time+1))))
rt_cross_tune_panel[((i-1)*(Time+1)+1):(i*(Time+1)), ] <- panel
}
#Sort by time
rt_cross_tune_panel <- rt_cross_tune_panel %>%
arrange(time)
#Remove 1st row because returns data only starts from t = 2
rt_cross_tune_panel <- rt_cross_tune_panel %>%
filter(time != 1) %>%
select(-time)
#Individual return R squared
rt_id_tune_df <- data.frame(
stock = c(1:200),
rsquare = c(1:200)
)
for (i in 1:N) {
rt_id_tune_panel <- rt_cross_tune_panel %>%
filter(stock == i)
SSR <- t(rt_id_tune_panel$resid) %*% rt_id_tune_panel$resid
#SST <- t(rt_id_tune_panel$return - mean(rt_id_tune_panel$return)) %*% (rt_id_tune_panel$return - mean(rt_id_tune_panel$return))
SST <- t(rt_id_tune_panel$return) %*% (rt_id_tune_panel$return)
rt_id_tune_df$rsquare[i] <- 1 - SSR/SST
}
#Return mean of each individual rsquared
mean(rt_id_tune_df$rsquare)
#Calculate Annualized Volatility
#Annualized volatility = calculate volatility (via standard deviation) for the monthly returns, then annualize it by multiplying it by sqrt(12) for 12 months in a year
vol_tune_df <- data.frame(
stock = c(1:200),
annual_vol = c(1:200)
)
for (i in 1:200) {
vol_tune_panel <- rt_cross_tune_panel %>%
filter(stock == i)
vol_tune_df$annual_vol[i] <- sd(vol_tune_panel$return) * sqrt(12)
}
#Return the mean annualized volatility
#Want this aorund 30%
mean(vol_tune_df$annual_vol)
#Cross sectional r squared
SSR <- t(rt_cross_tune_panel$resid) %*% (rt_cross_tune_panel$resid)
#SST <- t(rt_cross_tune_panel$return - mean(rt_cross_tune_panel$return)) %*% (rt_cross_tune_panel$return - mean(rt_cross_tune_panel$return))
SST <- t(rt_cross_tune_panel$return) %*% (rt_cross_tune_panel$return)
1 - SSR/SST
#This is quite off from Gu et al's specification and results. NOT GOOD
#Tuning Cross Sectional R Squared SKELETON CODE
#We want inidividual r squared for each stock to be 50%
#We want inidividual annualized volatility to be 30%
#We want to cross sectional R squared to be 25%
#We want the predictive R squared to be 5%
#Generate paramaters first
#Tune v_sd for inidividual r square first
#Gu et al had 0.05 for their v sd
v_sd <- 0.05
ep_sd <- 0.05
resid <- gu_gen_rt_resid(v_sd, ep_sd)
#Tune theta for cross sectional r square
#theta
theta <- matrix(c(0.02, 0.02, 0.02), nrow = 1)
rt <- gu_gen_rt(g1, resid)
rt_cross_tune_panel <- data.frame(
return = rep(0, 36000),
resid = rep(0, 36000),
time = rep(0, 36000),
stock = rep(0, 36000)
)
for (i in 1:N){
rt_cross_tune_df <- data.frame(
return = rep(0, Time+1),
resid = rep(0, Time+1),
time = rep(0, Time+1)
)
for (t in 1:(Time+1)){
rt_cross_tune_df$return[t] <- rt[[t]][i]
rt_cross_tune_df$resid[t] <- resid[[t]][i]
}
#Cbind returns, id, time and predictors
panel <- cbind(rt_cross_tune_df$return, rt_cross_tune_df$resid, c(1:(Time+1)), c(rep(i, (Time+1))))
rt_cross_tune_panel[((i-1)*(Time+1)+1):(i*(Time+1)), ] <- panel
}
#Sort by time
rt_cross_tune_panel <- rt_cross_tune_panel %>%
arrange(time)
#Remove 1st row because returns data only starts from t = 2
rt_cross_tune_panel <- rt_cross_tune_panel %>%
filter(time != 1) %>%
select(-time)
#Individual return R squared
rt_id_tune_df <- data.frame(
stock = c(1:200),
rsquare = c(1:200)
)
for (i in 1:N) {
rt_id_tune_panel <- rt_cross_tune_panel %>%
filter(stock == i)
SSR <- t(rt_id_tune_panel$resid) %*% rt_id_tune_panel$resid
#SST <- t(rt_id_tune_panel$return - mean(rt_id_tune_panel$return)) %*% (rt_id_tune_panel$return - mean(rt_id_tune_panel$return))
SST <- t(rt_id_tune_panel$return) %*% (rt_id_tune_panel$return)
rt_id_tune_df$rsquare[i] <- 1 - SSR/SST
}
#Return mean of each individual rsquared
mean(rt_id_tune_df$rsquare)
#Calculate Annualized Volatility
#Annualized volatility = calculate volatility (via standard deviation) for the monthly returns, then annualize it by multiplying it by sqrt(12) for 12 months in a year
vol_tune_df <- data.frame(
stock = c(1:200),
annual_vol = c(1:200)
)
for (i in 1:200) {
vol_tune_panel <- rt_cross_tune_panel %>%
filter(stock == i)
vol_tune_df$annual_vol[i] <- sd(vol_tune_panel$return) * sqrt(12)
}
#Return the mean annualized volatility
#Want this aorund 30%
mean(vol_tune_df$annual_vol)
#Cross sectional r squared
SSR <- t(rt_cross_tune_panel$resid) %*% (rt_cross_tune_panel$resid)
SST <- t(rt_cross_tune_panel$return - mean(rt_cross_tune_panel$return)) %*% (rt_cross_tune_panel$return - mean(rt_cross_tune_panel$return))
#SST <- t(rt_cross_tune_panel$return) %*% (rt_cross_tune_panel$return)
1 - SSR/SST
#This is quite off from Gu et al's specification and results. NOT GOOD
#Tuning Cross Sectional R Squared SKELETON CODE
#We want inidividual r squared for each stock to be 50%
#We want inidividual annualized volatility to be 30%
#We want to cross sectional R squared to be 25%
#We want the predictive R squared to be 5%
#Generate paramaters first
#Tune v_sd for inidividual r square first
#Gu et al had 0.05 for their v sd
v_sd <- 0.05
ep_sd <- 0.05
resid <- gu_gen_rt_resid(v_sd, ep_sd)
#Tune theta for cross sectional r square
#theta
theta <- matrix(c(0.02, 0.02, 0.02), nrow = 1)
rt <- gu_gen_rt(g1, resid)
rt_cross_tune_panel <- data.frame(
return = rep(0, 36000),
resid = rep(0, 36000),
time = rep(0, 36000),
stock = rep(0, 36000)
)
for (i in 1:N){
rt_cross_tune_df <- data.frame(
return = rep(0, Time+1),
resid = rep(0, Time+1),
time = rep(0, Time+1)
)
for (t in 1:(Time+1)){
rt_cross_tune_df$return[t] <- rt[[t]][i]
rt_cross_tune_df$resid[t] <- resid[[t]][i]
}
#Cbind returns, id, time and predictors
panel <- cbind(rt_cross_tune_df$return, rt_cross_tune_df$resid, c(1:(Time+1)), c(rep(i, (Time+1))))
rt_cross_tune_panel[((i-1)*(Time+1)+1):(i*(Time+1)), ] <- panel
}
#Sort by time
rt_cross_tune_panel <- rt_cross_tune_panel %>%
arrange(time)
#Remove 1st row because returns data only starts from t = 2
rt_cross_tune_panel <- rt_cross_tune_panel %>%
filter(time != 1) %>%
select(-time)
#Individual return R squared
rt_id_tune_df <- data.frame(
stock = c(1:200),
rsquare = c(1:200)
)
for (i in 1:N) {
rt_id_tune_panel <- rt_cross_tune_panel %>%
filter(stock == i)
SSR <- t(rt_id_tune_panel$resid) %*% rt_id_tune_panel$resid
#SST <- t(rt_id_tune_panel$return - mean(rt_id_tune_panel$return)) %*% (rt_id_tune_panel$return - mean(rt_id_tune_panel$return))
SST <- t(rt_id_tune_panel$return) %*% (rt_id_tune_panel$return)
rt_id_tune_df$rsquare[i] <- 1 - SSR/SST
}
#Return mean of each individual rsquared
mean(rt_id_tune_df$rsquare)
#Calculate Annualized Volatility
#Annualized volatility = calculate volatility (via standard deviation) for the monthly returns, then annualize it by multiplying it by sqrt(12) for 12 months in a year
vol_tune_df <- data.frame(
stock = c(1:200),
annual_vol = c(1:200)
)
for (i in 1:200) {
vol_tune_panel <- rt_cross_tune_panel %>%
filter(stock == i)
vol_tune_df$annual_vol[i] <- sd(vol_tune_panel$return) * sqrt(12)
}
#Return the mean annualized volatility
#Want this aorund 30%
mean(vol_tune_df$annual_vol)
#Cross sectional r squared
SSR <- t(rt_cross_tune_panel$resid) %*% (rt_cross_tune_panel$resid)
SST <- t(rt_cross_tune_panel$return - mean(rt_cross_tune_panel$return)) %*% (rt_cross_tune_panel$return - mean(rt_cross_tune_panel$return))
SST <- t(rt_cross_tune_panel$return) %*% (rt_cross_tune_panel$return)
1 - SSR/SST
#This is quite off from Gu et al's specification and results. NOT GOOD
