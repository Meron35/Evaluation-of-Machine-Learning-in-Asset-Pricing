v <- matrix(data = rnorm(3,mean=0, sd = v_sd),
nrow = 3,
ncol = 1)
for (i in 1:N) {
Beta_v[i, 1, t] <- Beta[i, , t] %*% v
}
}
###########
#SV errors
###########
if (sv == 1) {
##Generate Sigma first (only indexed by time)
sigma2 <- rep(0, Time+1)
#Initial sigma2
sigma2[1] <- omega + w
for (t in 1:Time+1) {
sigma2[t+1] <- omega + gamma*sigma2[t] + rnorm(1, 0, w)
}
for (t in 1:(Time)) {
for (i in 1:N) {
error[i, 1, t] <- exp(sigma2[t+1]/2) * rnorm(1, 0, ep_sd)
}
}
return(error + Beta_v)
}
##################
#NON-SV Student t errors
##################
else {
for (t in 1:(Time)) {
error[, , t] <- matrix(data = rt(N, df = 5) * sqrt(ep_sd^2 * (5-2)/5), nrow = N)
}
return(error + Beta_v)
}
}
#SV version check
error <- gen_error(sv = 1, ep_sd = 0.05, omega = -0.736, gamma = 0.90, w = sqrt(0.363), C, v_sd = 0.05)
#Non-SV version check
#You'll still need to specify values for omega, gamma and w, they just won't be used
error <- gen_error(sv = 0, ep_sd = 0.05, omega = -0.736, gamma = 0.90, w = sqrt(0.363), C, v_sd = 0.05)
#Both Working, yay
##Just a recap chunk of everything that needs to be run to generate everything thus far before we move on to tuning R squared
C_bar <- gen_C_bar()
C_hat <- gen_C_hat(C_bar)
#Change this to C_hat if you want to build in cross sectional correlation
C <- gen_C(C_bar)
A1 <- matrix(c(
0.95, 0, 0,
0, 0.95, 0,
0, 0, 0.95),
nrow = 3, ncol = 3
)
A2 <- matrix(c(
1, 0, 0.25,
0, 0.95, 0,
0.25, 0, 0.95),
nrow = 3, ncol = 3
)
A3 <- matrix(c(
0.99, 0.2, 0.1,
0.2, 0.90, -0.3,
0.1, -0.3, -0.99),
nrow = 3, ncol = 3
)
xt <- gen_xt(A1)
xt_univariate <- gen_xt_univariate()
#Generate the true underlying factors first
g1_factor_panel <- gen_g_factor_panel("g1", C, xt)
#Then pass them through to multiply them by theta to get g()
g1_panel <- gen_g_panel(g1_factor_panel, theta = matrix(c(0.04, 0.035, 0.01), nrow = 1))
#Generate the errors
#SV version
error_sv <- gen_error(sv = 1, ep_sd = 0.05, omega = -0.736, gamma = 0.90, w = sqrt(0.363), C, v_sd = 0.05)
#Non-SV version
error_nosv <- gen_error(sv = 0, ep_sd = 0.05, omega = -0.736, gamma = 0.90, w = sqrt(0.363), C, v_sd = 0.05)
#Finally generate a returns panel
rt_panel_g1_A1 <- g1_panel + error_nosv
#All works, hooray
#See Cochrane's book for more details and explanations, Chapter 12
# Absolutely no clue how Gu et al calibrated their R squared values
# But, their average time series R squared for each stock was 50%, average annualized volatility was 30%
# Cross sectional R squared was 25%, and predictive R squared was 5%.
# David was getting something around 20% time series r squared, and 5% cross sectional (double check)
# This is expected to reduce by a whole lot more as we increase the size of the panel, in terms of both time and cross section size
##########################################
# Time series R-squared
##########################################
## Methodology
# Run a standard regression for expected returns
# R_it = alpha_i + Beta_i * factor_t + e_it
# Save the coefficients for Beta from this, labelling them as Lambda
# Calculate the SSR and SST, and hence R squared for each stock return's time series
#Empty Matrices to be used
Rsquared <- matrix(0, N, 1)
SSR <- matrix(0, N, 1)
SST <- matrix(0, N, 1)
Fits <- matrix(0, Time, N)
#This stores all the BETAS, NOT the constant
Coeff_Betas <- matrix(0, N, 3)
Xs_bar <- matrix(0, N, 3)
R_bar <- matrix(0, N, 1)
Resids <- matrix(0, Time, N)
annual_vol <- matrix(0, N, 1)
#Done for the g1 case for now
#First run individual time series regressions
for (i in 1:N) {
#True Returns
Rs <- rt_panel_g1_A1[i, , ]
R_bar[i, 1] <- mean(Rs)
#True Factor Set
Xs <- t(g1_factor_panel[i, , ])
#Not too sure what this is doing, not used anywhere else
Xs_bar[i, ] <- colMeans(Xs)
df <- data.frame(Rs, Xs)
fit <- lm(Rs ~., df)
Fits[, i] <- fit$fitted.values
#Save all the betas except for the constant, slightly more clever way that handles different number of true factors
Coeff_Betas[i, ] <- as.numeric(fit$coefficients[-1])
Resids[, i] <- fit$residuals
SSR[i, 1]<- sum(Resids[, i]^2)
SST[i, 1]<- sum((Rs-mean(Rs))^2)
Rsquared[i, 1]<-summary(fit)$r.squared
#annualized volatility
annual_vol[i] <- sd(Rs) * sqrt(12)
}
mean(Rsquared)
#The no sv designs makes all stocks have pretty similar volatility, hmmmm
mean(annual_vol)
# Not too sure what is going on here
# val <- g1(C,x,theta)
# true_res <- rowSums((rt - val)^2)
# true_sst <- rowSums((rt - rowMeans(rt))^2)
# true_rRsquared <- 1 - (sum(true_res)/sum(true_sst))
#
# fitted_Rsquared <- 1 - (sum(SSR)/sum(SST))
##########################################
# Cross-sectional R-squared
##########################################
#Run a cross sectional regression of average returns on the estimated betas from before
# E(Rei) = alpha_i (constant) + B_i * lambda
R_bar <- rowMeans(rt_panel_g1_A1)
df_new <- data.frame(R_bar, Coeff_Betas)
cross_fit <- lm(R_bar~ Coeff_Betas, df_new)
summary(cross_fit)$r.squared
# This gives us the cross sectional R squared
# Same as David, both of their r squared values are off
############################
# Function Form
############################
# Given a return series panel, its signal (non-error component), and its corresponding underlying true factors, return its mean individual time series R squared, mean annualized volatility, cross sectional r squared and predictive r squared
panel_tune_stats <- function(return_panel, signal_panel, true_factor_panel) {
#Initialize
tune_stats <- data.frame(time_series_fitted.rsquare = 0, annual_vol = 0, true_rsquare = 0, cross_section_rsquare = 0)
########
## Time Series + Annual Vol
########
#Empty Matrices to be used
Rsquared <- matrix(0, N, 1)
SSR <- matrix(0, N, 1)
SST <- matrix(0, N, 1)
Fits <- matrix(0, Time, N)
#This stores all the BETAS, NOT the constant
Coeff_Betas <- matrix(0, N, ncol(true_factor_panel))
Xs_bar <- matrix(0, N, ncol(true_factor_panel))
R_bar <- matrix(0, N, 1)
Resids <- matrix(0, Time, N)
annual_vol <- matrix(0, N, 1)
#Done for the g1 case for now
#First run individual time series regressions
for (i in 1:N) {
#True Returns
Rs <- return_panel[i, , ]
R_bar[i, 1] <- mean(Rs)
#True Factor Set
Xs <- t(true_factor_panel[i, , ])
#Not too sure what this is doing, not used anywhere else
Xs_bar[i, ] <- colMeans(Xs)
df <- data.frame(Rs, Xs)
fit <- lm(Rs ~., df)
Fits[, i] <- fit$fitted.values
#Save all the betas except for the constant, slightly more clever way that handles different number of true factors
Coeff_Betas[i, ] <- as.numeric(fit$coefficients[-1])
Resids[, i] <- fit$residuals
SSR[i, 1] <- sum(Resids[, i]^2)
SST[i, 1] <- sum((Rs-mean(Rs))^2)
Rsquared[i, 1] <- summary(fit)$r.squared
#annualized volatility
annual_vol[i] <- sd(Rs) * sqrt(12)
}
tune_stats$time_series_fitted.rsquare <- mean(Rsquared)
tune_stats$annual_vol <- mean(annual_vol)
#Predictive R Squared
tune_stats$true_rsquare <- R2(signal_panel, return_panel, form = "traditional")
# Not too sure what is going on here
# val <- g1(C,x,theta)
# true_res <- rowSums((rt - val)^2)
# true_sst <- rowSums((rt - rowMeans(rt))^2)
# true_rRsquared <- 1 - (sum(true_res)/sum(true_sst))
# fitted_Rsquared <- 1 - (sum(SSR)/sum(SST))
# Cross Sectional Correlation
R_bar <- rowMeans(return_panel)
df_new <- data.frame(R_bar, Coeff_Betas)
cross_fit <- lm(R_bar ~ Coeff_Betas, df_new)
tune_stats$cross_section_rsquare <- summary(cross_fit)$r.squared
return(tune_stats)
}
#Works, hooray
panel_tune_stats(rt_panel_g1_A1, g1_panel, g1_factor_panel)
############################
# Function Form
############################
# Given a return series panel, its signal (non-error component), and its corresponding underlying true factors, return its mean individual time series R squared, mean annualized volatility, cross sectional r squared and predictive r squared
# Alternative approach which Gu et al may have used
# They may have instead regressed on the entire predictor set, instead of the true factor panels
# Never mind, this DOES NOT work at all because the dimensions of the entire predictor set > number of time periods. Ie. individual time series regression become impossible
# Given a return series panel, its signal (non-error component), and a corresponding predictor set (NOT true factors), return its means individual time series R squared, mean annualized volatility, cross sectional r squared and predictive r squared
panel_tune_stats <- function(return_panel, signal_panel, predictor_panel) {
#Initialize
tune_stats <- data.frame(time_series_fitted.rsquare = 0, annual_vol = 0, true_rsquare = 0, cross_section_rsquare = 0)
########
## Time Series + Annual Vol
########
#Empty Matrices to be used
Rsquared <- matrix(0, N, 1)
SSR <- matrix(0, N, 1)
SST <- matrix(0, N, 1)
Fits <- matrix(0, Time, N)
#This stores all the BETAS, NOT the constant
Coeff_Betas <- matrix(0, N, ncol(predictor_panel))
Xs_bar <- matrix(0, N, ncol(predictor_panel))
R_bar <- matrix(0, N, 1)
Resids <- matrix(0, Time, N)
annual_vol <- matrix(0, N, 1)
#Done for the g1 case for now
#First run individual time series regressions
for (i in 1:N) {
#True Returns
Rs <- return_panel[i, , ]
R_bar[i, 1] <- mean(Rs)
#True Factor Set
Xs <- t(predictor_panel[i, , ])
#Not too sure what this is doing, not used anywhere else
Xs_bar[i, ] <- colMeans(Xs)
df <- data.frame(Rs, Xs)
fit <- lm(Rs ~., df)
Fits[, i] <- fit$fitted.values
#Save all the betas except for the constant, slightly more clever way that handles different number of true factors
Coeff_Betas[i, ] <- as.numeric(fit$coefficients[-1])
Resids[, i] <- fit$residuals
SSR[i, 1] <- sum(Resids[, i]^2)
SST[i, 1] <- sum((Rs-mean(Rs))^2)
Rsquared[i, 1] <- summary(fit)$r.squared
#annualized volatility
annual_vol[i] <- sd(Rs) * sqrt(12)
}
tune_stats$time_series_fitted.rsquare <- mean(Rsquared)
tune_stats$annual_vol <- mean(annual_vol)
#Predictive R Squared
tune_stats$true_rsquare <- R2(signal_panel, return_panel, form = "traditional")
# Not too sure what is going on here
# val <- g1(C,x,theta)
# true_res <- rowSums((rt - val)^2)
# true_sst <- rowSums((rt - rowMeans(rt))^2)
# true_rRsquared <- 1 - (sum(true_res)/sum(true_sst))
# fitted_Rsquared <- 1 - (sum(SSR)/sum(SST))
# Cross Sectional Correlation
R_bar <- rowMeans(return_panel)
df_new <- data.frame(R_bar, Coeff_Betas)
cross_fit <- lm(R_bar ~ Coeff_Betas, df_new)
tune_stats$cross_section_rsquare <- summary(cross_fit)$r.squared
return(tune_stats)
}
#Works, hooray
# Testing
xt_univariate <- gen_xt_univariate()
#Generate the true underlying factors first
g1_factor_panel <- gen_g_factor_panel("g1", C, xt)
#Then pass them through to multiply them by theta to get g()
g1_panel <- gen_g_panel(g1_factor_panel, theta = matrix(c(0.04, 0.035, 0.01), nrow = 1))
#Generate the errors
#SV version
error_sv <- gen_error(sv = 1, ep_sd = 0.05, omega = -0.736, gamma = 0.90, w = sqrt(0.363), C, v_sd = 0.05)
#Non-SV version
error_nosv <- gen_error(sv = 0, ep_sd = 0.05, omega = -0.736, gamma = 0.90, w = sqrt(0.363), C, v_sd = 0.05)
#Finally generate a returns panel
rt_panel_g1_A1 <- g1_panel + error_nosv
# Generate a predictor panel
z_panel_g1_A1 <- gen_predictor_z(C, xt)
##############################################################################
##Function to build predictor set for the entire panel
##############################################################################
#Kronecker product
# Calculated with z_it = (1, xt)' \otimes c_it
# xt should be P_x x 1
# c_it should be P_c x 1
# z_it should be a P_c*(P_x + 1) x 1 vector of features
gen_predictor_z <- function(C, x){
xt_set <- rbind(1, x)
dimnames(xt_set)[[1]][1] <- "constant"
stock_dim <- paste0("stock_", c(1:N))
c_dim <- dimnames(kronecker(t(xt_set[, 1]), t(C[1, , 1]), make.dimnames = TRUE))[[2]]
time_dim <- paste0("time_", c(1:(Time)))
z_panel <- array(0, dim = c(N, (nrow(xt_set)) * P_c, Time), dimnames = list(stock_dim, c_dim, time_dim))
for (i in 1:N) {
for (t in 1:Time) {
z_panel[i, , t] <- kronecker(t(xt_set[, t]), t(C[i, , t]), make.dimnames = TRUE)
}
}
return(z_panel)
}
z_panel_g1_A1 <- gen_predictor_z(C, xt)
#Yes bitch it's working
# Bind Returns and Predictor Sets Together into one 2D dataframe, ready to be used for training models
bind_rt_predictor <- function(rt_panel, z_panel) {
df <- cbind(data.frame(rt_panel[, , 1]), time = 2, stock = paste0("stock_", c(1:N)), data.frame(z_panel[, , 1]))
colnames(df)[1] <- "rt"
row.names(df) <- NULL
for (t in 2:Time) {
df_new <- cbind(data.frame(rt_panel[, , t]), time = 1+t, stock = paste0("stock_", c(1:N)), data.frame(z_panel[, , t]))
colnames(df_new)[1] <- "rt"
row.names(df_new) <- NULL
df <- rbind(df, df_new)
}
return(df)
}
#test
panel_g1_A1 <- bind_rt_predictor(rt_panel_g1_A1, z_panel_g1_A1)
#With that... DONE WITH THIS PART OF THE PROJECT
##########################
A1 <- matrix(c(
0.95, 0, 0,
0, 0.95, 0,
0, 0, 0.95),
nrow = 3, ncol = 3
)
A2 <- matrix(c(
1, 0, 0.25,
0, 0.95, 0,
0.25, 0, 0.95),
nrow = 3, ncol = 3
)
A3 <- matrix(c(
0.99, 0.2, 0.1,
0.2, 0.90, -0.3,
0.1, -0.3, -0.99),
nrow = 3, ncol = 3
)
##########################
# Simulate a specification 100 times
# This is very slow due to use of for loops
# Parellelize this
sim_panel_data_parallel <- function(sim_N, cross_corr, A_matrix, xt_multi, g_function, theta,
#Error Parameters
error_sv, error_ep_sd, error_omega, error_gamma, error_w, error_v_sd) {
sim_list <- foreach(i = (1:sim_N)) %dopar% {
sim_list <- list(panel = 0, statistics = 0)
C_bar <- gen_C_bar()
C_hat <- gen_C_hat(C_bar)
if (cross_corr == 0) {
C <- gen_C(C_bar)
}
else {
C <- gen_C(C_hat)
}
if (xt_multi == 1) {
xt <- gen_xt(A_matrix)
}
else {
xt <- gen_xt_univariate()
}
#Generate the true underlying factors first
g_factor_panel <- gen_g_factor_panel(g_function, C, xt)
#Then pass them through to multiply them by theta to get g()
g_panel <- gen_g_panel(g_factor_panel, theta)
#Generate the errors
error <- gen_error(sv = error_sv, ep_sd = error_ep_sd, omega = error_omega, gamma = error_gamma, w = error_w, C, v_sd = error_v_sd)
#rt panel
rt_panel <- g_panel + error
z_panel <- gen_predictor_z(C, xt)
sim_list$panel <- bind_rt_predictor(rt_panel, z_panel)
#Statistics
sim_list$statistics <- panel_tune_stats(rt_panel, g_panel, g_factor_panel)
}
return(sim_list)
}
sim_panel_data_parallel(10, cross_corr = 0, A1, xt_multi = 0, g_function = "g1", theta = matrix(c(0.02, 0.02, 0.02), nrow = 1),
error_sv = 0, error_ep_sd = 0.05, error_omega = -0.736, error_gamma = 0.9, error_w = sqrt(0.363), error_v_sd = 0.05)
getDoParWorkers()
sim_panel_data_parallel(10, cross_corr = 0, A1, xt_multi = 0, g_function = "g1", theta = matrix(c(0.02, 0.02, 0.02), nrow = 1),
error_sv = 0, error_ep_sd = 0.05, error_omega = -0.736, error_gamma = 0.9, error_w = sqrt(0.363), error_v_sd = 0.05)
library(doMC)
install.packages("doMC")
install.packages("doFuture")
library(doFuture)
?registerDoFuture
?plan
plan(multisession)
sim_panel_data_parallel(10, cross_corr = 0, A1, xt_multi = 0, g_function = "g1", theta = matrix(c(0.02, 0.02, 0.02), nrow = 1),
error_sv = 0, error_ep_sd = 0.05, error_omega = -0.736, error_gamma = 0.9, error_w = sqrt(0.363), error_v_sd = 0.05)
#Registering
# Change this to the number of cores you are willing to spare
# Honours lab computers have 12 logical cores, i5 at home has 4 logical cores
registerDoFuture()
plan(multisession)
#Parallel Computing
library(foreach)
sim_panel_data_parallel(10, cross_corr = 0, A1, xt_multi = 0, g_function = "g1", theta = matrix(c(0.02, 0.02, 0.02), nrow = 1),
error_sv = 0, error_ep_sd = 0.05, error_omega = -0.736, error_gamma = 0.9, error_w = sqrt(0.363), error_v_sd = 0.05)
library(glmnet)
library(tidyverse)
library(keras)
library(ggplot2)
library(forecast)
library(rlist)
library(plm)
library(Metrics)
library(ranger)
library(caret)
sim_panel_data_parallel(10, cross_corr = 0, A1, xt_multi = 0, g_function = "g1", theta = matrix(c(0.02, 0.02, 0.02), nrow = 1),
error_sv = 0, error_ep_sd = 0.05, error_omega = -0.736, error_gamma = 0.9, error_w = sqrt(0.363), error_v_sd = 0.05)
gu_et_al_g1 <- sim_panel_data_parallel(10, cross_corr = 0, A1, xt_multi = 0, g_function = "g1", theta = matrix(c(0.02, 0.02, 0.02), nrow = 1),
error_sv = 0, error_ep_sd = 0.05, error_omega = -0.736, error_gamma = 0.9, error_w = sqrt(0.363), error_v_sd = 0.05)
View(gu_et_al_g1)
sim_panel_data_parallel <- function(sim_N, cross_corr, A_matrix, xt_multi, g_function, theta,
#Error Parameters
error_sv, error_ep_sd, error_omega, error_gamma, error_w, error_v_sd) {
sim_list <- foreach(i = (1:sim_N)) %dopar% {
C_bar <- gen_C_bar()
C_hat <- gen_C_hat(C_bar)
if (cross_corr == 0) {
C <- gen_C(C_bar)
}
else {
C <- gen_C(C_hat)
}
if (xt_multi == 1) {
xt <- gen_xt(A_matrix)
}
else {
xt <- gen_xt_univariate()
}
#Generate the true underlying factors first
g_factor_panel <- gen_g_factor_panel(g_function, C, xt)
#Then pass them through to multiply them by theta to get g()
g_panel <- gen_g_panel(g_factor_panel, theta)
#Generate the errors
error <- gen_error(sv = error_sv, ep_sd = error_ep_sd, omega = error_omega, gamma = error_gamma, w = error_w, C, v_sd = error_v_sd)
#rt panel
rt_panel <- g_panel + error
z_panel <- gen_predictor_z(C, xt)
sim_panel <- bind_rt_predictor(rt_panel, z_panel)
}
return(sim_list)
}
gu_et_al_g1 <- sim_panel_data_parallel(10, cross_corr = 0, A1, xt_multi = 0, g_function = "g1", theta = matrix(c(0.02, 0.02, 0.02), nrow = 1),
error_sv = 0, error_ep_sd = 0.05, error_omega = -0.736, error_gamma = 0.9, error_w = sqrt(0.363), error_v_sd = 0.05)
sim_panel_data_parallel <- function(sim_N, cross_corr, A_matrix, xt_multi, g_function, theta,
#Error Parameters
error_sv, error_ep_sd, error_omega, error_gamma, error_w, error_v_sd) {
sim_list <- foreach(i = (1:sim_N)) %dopar% {
sim <- list(panel = 0, statistics = 0)
C_bar <- gen_C_bar()
C_hat <- gen_C_hat(C_bar)
if (cross_corr == 0) {
C <- gen_C(C_bar)
}
else {
C <- gen_C(C_hat)
}
if (xt_multi == 1) {
xt <- gen_xt(A_matrix)
}
else {
xt <- gen_xt_univariate()
}
#Generate the true underlying factors first
g_factor_panel <- gen_g_factor_panel(g_function, C, xt)
#Then pass them through to multiply them by theta to get g()
g_panel <- gen_g_panel(g_factor_panel, theta)
#Generate the errors
error <- gen_error(sv = error_sv, ep_sd = error_ep_sd, omega = error_omega, gamma = error_gamma, w = error_w, C, v_sd = error_v_sd)
#rt panel
rt_panel <- g_panel + error
z_panel <- gen_predictor_z(C, xt)
sim$panel <- bind_rt_predictor(rt_panel, z_panel)
sim$statistics <- panel_tune_stats(rt_panel, g_panel, g_factor_panel)
sim
}
return(sim_list)
}
gu_et_al_g1 <- sim_panel_data_parallel(10, cross_corr = 0, A1, xt_multi = 0, g_function = "g1", theta = matrix(c(0.02, 0.02, 0.02), nrow = 1),
error_sv = 0, error_ep_sd = 0.05, error_omega = -0.736, error_gamma = 0.9, error_w = sqrt(0.363), error_v_sd = 0.05)
View(gu_et_al_g1)
gu_et_al_g1 <- sim_panel_data_parallel(100, cross_corr = 0, A1, xt_multi = 0, g_function = "g1", theta = matrix(c(0.02, 0.02, 0.02), nrow = 1),
error_sv = 0, error_ep_sd = 0.05, error_omega = -0.736, error_gamma = 0.9, error_w = sqrt(0.363), error_v_sd = 0.05)
sim_tune_statistics <- function(sim_panel_list) {
sim_N <- length(sim_panel_list)
#Initialize
sim_tune_stats <- data.frame(time_series_fitted.rsquare = rep(0, sim_N),
annual_vol = rep(0, sim_N),
true_rsquare = rep(0, sim_N),
cross_section_rsquare = rep(0, sim_N))
for (i in 1:sim_N) {
sim_tune_stats[i, ] <- sim_panel_list[[i]]$statistics
}
return(sim_tune_stats)
}
summary(sim_tune_statistics(gu_et_al_g1))
gu_et_al_g2 <- sim_panel_data_parallel(100, cross_corr = 0, A1, xt_multi = 0, g_function = "g2", theta = matrix(c(0.04, 0.035, 0.01), nrow = 1),
error_sv = 0, error_ep_sd = 0.05, error_omega = -0.736, error_gamma = 0.9, error_w = sqrt(0.363), error_v_sd = 0.05)
summary(sim_tune_statistics(gu_et_al_g1))
summary(sim_tune_statistics(gu_et_al_g2))
