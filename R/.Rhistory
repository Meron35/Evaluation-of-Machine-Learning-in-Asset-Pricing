}
else {
C <- gen_C(C_hat)
}
if (xt_multi == 1) {
xt <- gen_xt(A_matrix)
}
else {
xt <- gen_xt_univariate()
}
#Generate the true underlying factors first
g_factor_panel <- gen_g_factor_panel(g_function, C, xt)
#Then pass them through to multiply them by theta to get g()
g_panel <- gen_g_panel(g_factor_panel, theta)
#Generate the errors
error <- gen_error(sv = error_sv, ep_sd = error_ep_sd, omega = error_omega, gamma = error_gamma, w = error_w, C, v_sd = error_v_sd)
#rt panel
rt_panel <- g_panel + error
z_panel <- gen_predictor_z(C, xt)
sim$panel <- bind_rt_predictor(rt_panel, z_panel)
sim$statistics <- panel_tune_stats(rt_panel, g_panel, g_factor_panel)
sim
}
return(sim_list)
}
# This function is very straightforward and does not need to be parallelized
# Run this after generating the data from the previous function (see example right below)
sim_tune_statistics <- function(sim_panel_list) {
sim_N <- length(sim_panel_list)
#Initialize
sim_tune_stats <- data.frame(time_series_fitted.rsquare = rep(0, sim_N),
annual_vol = rep(0, sim_N),
true_rsquare = rep(0, sim_N),
cross_section_rsquare = rep(0, sim_N))
for (i in 1:sim_N) {
sim_tune_stats[i, ] <- sim_panel_list[[i]]$statistics
}
return(sim_tune_stats)
}
# gu_et_al_g1 <- sim_panel_data_parallel(100, cross_corr = 0, A1, xt_multi = 0, g_function = "g1", theta = matrix(c(0.02, 0.02, 0.02), nrow = 1),
#                                        error_sv = 0, error_ep_sd = 0.05, error_omega = -0.736, error_gamma = 0.9, error_w = sqrt(0.363), error_v_sd = 0.05)
#
# gu_et_al_g2 <- sim_panel_data_parallel(100, cross_corr = 0, A1, xt_multi = 0, g_function = "g2", theta = matrix(c(0.04, 0.035, 0.01), nrow = 1),
#                                        error_sv = 0, error_ep_sd = 0.05, error_omega = -0.736, error_gamma = 0.9, error_w = sqrt(0.363), error_v_sd = 0.05)
#
# summary(sim_tune_statistics(gu_et_al_g1))
#
# summary(sim_tune_statistics(gu_et_al_g2))
# Observations
# You need a reasonably large number of simulations in order to gauge these designs
# Turning the simulation number from 10 to 100 does yield some changes
# Gu et al's design doesn't seem to be replicable
# True r squared (predictive r squared) is somewhat close to what they specified
set.seed(27935248)
#Overall Dimensionality
N <- 200
P_c <- 100
Time <- 180
#Number of realizations
simN <- 50
gu_et_al_g1 <- sim_panel_data(simN,
char_rho_a = 0.9, char_rho_b = 1,
cross_corr = 0, A1, xt_multi = 0, g_function = "g1", theta = matrix(c(0.02, 0.02, 0.02), nrow = 1),
error_sv = 0, error_ep_sd = 0.05,
error_omega = -0.736, error_gamma = 0.9, error_w = sqrt(0.363), error_v_sd = 0.05)
##########################
A1 <- matrix(c(
0.95, 0, 0,
0, 0.95, 0,
0, 0, 0.95),
nrow = 3, ncol = 3
)
A2 <- matrix(c(
1, 0, 0.25,
0, 0.95, 0,
0.25, 0, 0.95),
nrow = 3, ncol = 3
)
A3 <- matrix(c(
0.99, 0.2, 0.1,
0.2, 0.90, -0.3,
0.1, -0.3, -0.99),
nrow = 3, ncol = 3
)
##########################
# Parallel implementation of simulation design
# This is absolutely amazing, finishes 100 simulations in less than 5 minutes on 12 logical cores
sim_panel_data <- function(sim_N,
char_rho_a, char_rho_b,
cross_corr, A_matrix, xt_multi, g_function, theta,
#Error Parameters
error_sv, error_ep_sd, error_omega, error_gamma, error_w, error_v_sd) {
sim_list <- foreach(i = (1:sim_N)) %dopar% {
sim <- list(panel = 0, statistics = 0)
C_bar <- gen_C_bar(char_rho_a, char_rho_b)
C_hat <- gen_C_hat(C_bar)
if (cross_corr == 0) {
C <- gen_C(C_bar)
}
else {
C <- gen_C(C_hat)
}
if (xt_multi == 1) {
xt <- gen_xt(A_matrix)
}
else {
xt <- gen_xt_univariate()
}
#Generate the true underlying factors first
g_factor_panel <- gen_g_factor_panel(g_function, C, xt)
#Then pass them through to multiply them by theta to get g()
g_panel <- gen_g_panel(g_factor_panel, theta)
#Generate the errors
error <- gen_error(sv = error_sv, ep_sd = error_ep_sd, omega = error_omega, gamma = error_gamma, w = error_w, C, v_sd = error_v_sd)
#rt panel
rt_panel <- g_panel + error
z_panel <- gen_predictor_z(C, xt)
sim$panel <- bind_rt_predictor(rt_panel, z_panel)
sim$statistics <- panel_tune_stats(rt_panel, g_panel, g_factor_panel)
sim
}
return(sim_list)
}
# This function is very straightforward and does not need to be parallelized
# Run this after generating the data from the previous function (see example right below)
sim_tune_statistics <- function(sim_panel_list) {
sim_N <- length(sim_panel_list)
#Initialize
sim_tune_stats <- data.frame(time_series_fitted.rsquare = rep(0, sim_N),
annual_vol = rep(0, sim_N),
true_rsquare = rep(0, sim_N),
cross_section_rsquare = rep(0, sim_N))
for (i in 1:sim_N) {
sim_tune_stats[i, ] <- sim_panel_list[[i]]$statistics
}
return(sim_tune_stats)
}
# gu_et_al_g1 <- sim_panel_data_parallel(100, cross_corr = 0, A1, xt_multi = 0, g_function = "g1", theta = matrix(c(0.02, 0.02, 0.02), nrow = 1),
#                                        error_sv = 0, error_ep_sd = 0.05, error_omega = -0.736, error_gamma = 0.9, error_w = sqrt(0.363), error_v_sd = 0.05)
#
# gu_et_al_g2 <- sim_panel_data_parallel(100, cross_corr = 0, A1, xt_multi = 0, g_function = "g2", theta = matrix(c(0.04, 0.035, 0.01), nrow = 1),
#                                        error_sv = 0, error_ep_sd = 0.05, error_omega = -0.736, error_gamma = 0.9, error_w = sqrt(0.363), error_v_sd = 0.05)
#
# summary(sim_tune_statistics(gu_et_al_g1))
#
# summary(sim_tune_statistics(gu_et_al_g2))
# Observations
# You need a reasonably large number of simulations in order to gauge these designs
# Turning the simulation number from 10 to 100 does yield some changes
# Gu et al's design doesn't seem to be replicable
# True r squared (predictive r squared) is somewhat close to what they specified
gu_et_al_g1 <- sim_panel_data(simN,
char_rho_a = 0.9, char_rho_b = 1,
cross_corr = 0, A1, xt_multi = 0, g_function = "g1", theta = matrix(c(0.02, 0.02, 0.02), nrow = 1),
error_sv = 0, error_ep_sd = 0.05,
error_omega = -0.736, error_gamma = 0.9, error_w = sqrt(0.363), error_v_sd = 0.05)
summary(sim_tune_statistics(gu_et_al_g1))
saveRDS(gu_et_al_g1, file = "gut_et_al_g1.rds")
gu_et_al_g2 <- sim_panel_data(simN,
char_rho_a = 0.9, char_rho_b = 1,
cross_corr = 0, A1, xt_multi = 0, g_function = "g2", theta = matrix(c(0.04, 0.035, 0.01), nrow = 1),
error_sv = 0, error_ep_sd = 0.05,
error_omega = -0.736, error_gamma = 0.9, error_w = sqrt(0.363), error_v_sd = 0.05)
summary(sim_tune_statistics(gu_et_al_g2))
saveRDS(gu_et_al_g1, file = "gut_et_al_g2.rds")
rm(gu_et_al_g1)
rm(gu_et_al_g2)
g1_A1_panel <- sim_panel_data(simN,
char_rho_a = 0.5, char_rho_b = 1,
cross_corr = 1, A1, xt_multi = 1, g_function = "g1", theta = matrix(c(0.001, 0.001, 0.001), nrow = 1),
error_sv = 1, error_ep_sd = 0.05,
error_omega = -0.736, error_gamma = 0.9, error_w = sqrt(0.363), error_v_sd = 0.05)
summary(sim_tune_statistics(g1_A1_panel))
saveRDS(g1_A1_panel, file = "g1_A1.rds")
g1_A1_panel <- sim_panel_data(simN,
char_rho_a = 0.5, char_rho_b = 1,
cross_corr = 1, A1, xt_multi = 1, g_function = "g1", theta = matrix(c(0.02, 0.02, 0.02), nrow = 1),
error_sv = 1, error_ep_sd = 0.05,
error_omega = -0.736, error_gamma = 0.9, error_w = sqrt(0.363), error_v_sd = 0.05)
summary(sim_tune_statistics(g1_A1_panel))
saveRDS(g1_A1_panel, file = "g1_A1.rds")
g1_A1_panel <- sim_panel_data(simN,
char_rho_a = 0.5, char_rho_b = 1,
cross_corr = 1, A1, xt_multi = 1, g_function = "g1", theta = matrix(c(0.005, 0.005, 0.005), nrow = 1),
error_sv = 1, error_ep_sd = 0.05,
error_omega = -0.736, error_gamma = 0.9, error_w = sqrt(0.363), error_v_sd = 0.05)
summary(sim_tune_statistics(g1_A1_panel))
saveRDS(g1_A1_panel, file = "g1_A1.rds")
g1_A1_panel <- sim_panel_data(simN,
char_rho_a = 0.5, char_rho_b = 1,
cross_corr = 1, A1, xt_multi = 1, g_function = "g1", theta = matrix(c(0.007, 0.007, 0.007), nrow = 1),
error_sv = 1, error_ep_sd = 0.05,
error_omega = -0.736, error_gamma = 0.9, error_w = sqrt(0.363), error_v_sd = 0.05)
summary(sim_tune_statistics(g1_A1_panel))
saveRDS(g1_A1_panel, file = "g1_A1.rds")
rm(gt_A1_panel)
rm(g1_A1_panel)
g1_A2_panel <- sim_panel_data(simN,
char_rho_a = 0.5, char_rho_b = 1,
cross_corr = 1, A2, xt_multi = 1, g_function = "g1", theta = matrix(c(0.007, 0.007, 0.007), nrow = 1),
error_sv = 1, error_ep_sd = 0.05,
error_omega = -0.736, error_gamma = 0.9, error_w = sqrt(0.363), error_v_sd = 0.05)
summary(sim_tune_statistics(g1_A2_panel))
saveRDS(g1_A2_panel, file = "g1_A2.rds")
rm(g1_A2_panel)
g1_A3_panel <- sim_panel_data(simN,
char_rho_a = 0.5, char_rho_b = 1,
cross_corr = 1, A3, xt_multi = 1, g_function = "g1", theta = matrix(c(0.007, 0.007, 0.007), nrow = 1),
error_sv = 1, error_ep_sd = 0.05,
error_omega = -0.736, error_gamma = 0.9, error_w = sqrt(0.363), error_v_sd = 0.05)
summary(sim_tune_statistics(g1_A3_panel))
saveRDS(g1_A3_panel, file = "g1_A3.rds")
rm(g1_A3_panel)
g2_A1_panel <- sim_panel_data(simN,
char_rho_a = 0.5, char_rho_b = 1,
cross_corr = 1, A1, xt_multi = 1, g_function = "g2", theta = matrix(c(0.04, 0.035, 0.01), nrow = 1),
error_sv = 1, error_ep_sd = 0.05,
error_omega = -0.736, error_gamma = 0.9, error_w = sqrt(0.363), error_v_sd = 0.05)
summary(sim_tune_statistics(g2_A1_panel))
saveRDS(g2_A1_panel, file = "g2_A1.rds")
rm(g2_A1_panel)
g3_A1_panel <- sim_panel_data(simN,
char_rho_a = 0.5, char_rho_b = 1,
cross_corr = 1, A1, xt_multi = 1, g_function = "g3", theta = matrix(c(0.02, 0.02, 0.02, 0.02), nrow = 1),
error_sv = 1, error_ep_sd = 0.05,
error_omega = -0.736, error_gamma = 0.9, error_w = sqrt(0.363), error_v_sd = 0.05)
summary(sim_tune_statistics(g3_A1_panel))
saveRDS(g3_A1_panel, file = "g3_A1.rds")
g3_A1_panel <- sim_panel_data(simN,
char_rho_a = 0.5, char_rho_b = 1,
cross_corr = 1, A1, xt_multi = 1, g_function = "g3", theta = matrix(c(0.01, 0.01, 0.01, 0.01), nrow = 1),
error_sv = 1, error_ep_sd = 0.05,
error_omega = -0.736, error_gamma = 0.9, error_w = sqrt(0.363), error_v_sd = 0.05)
summary(sim_tune_statistics(g3_A1_panel))
g3_A1_panel <- sim_panel_data(simN,
char_rho_a = 0.5, char_rho_b = 1,
cross_corr = 1, A1, xt_multi = 1, g_function = "g3", theta = matrix(c(0.015, 0.015, 0.015, 0.015), nrow = 1),
error_sv = 1, error_ep_sd = 0.05,
error_omega = -0.736, error_gamma = 0.9, error_w = sqrt(0.363), error_v_sd = 0.05)
summary(sim_tune_statistics(g3_A1_panel))
g3_A1_panel <- sim_panel_data(simN,
char_rho_a = 0.5, char_rho_b = 1,
cross_corr = 1, A1, xt_multi = 1, g_function = "g3", theta = matrix(c(0.015, 0.015, 0.015, 0.02), nrow = 1),
error_sv = 1, error_ep_sd = 0.05,
error_omega = -0.736, error_gamma = 0.9, error_w = sqrt(0.363), error_v_sd = 0.05)
summary(sim_tune_statistics(g3_A1_panel))
rm(g3_A1_panel)
gu_et_al_g1 <- sim_panel_data(simN,
char_rho_a = 0.9, char_rho_b = 1,
cross_corr = 0, A1, xt_multi = 0, g_function = "g1", theta = matrix(c(0.02, 0.02, 0.02), nrow = 1),
error_sv = 0, error_ep_sd = 0.05,
error_omega = -0.736, error_gamma = 0.9, error_w = sqrt(0.363), error_v_sd = 0.05)
summary(sim_tune_statistics(gu_et_al_g1))
gu_et_al_g2 <- sim_panel_data(simN,
char_rho_a = 0.9, char_rho_b = 1,
cross_corr = 0, A1, xt_multi = 0, g_function = "g2", theta = matrix(c(0.04, 0.035, 0.01), nrow = 1),
error_sv = 0, error_ep_sd = 0.05,
error_omega = -0.736, error_gamma = 0.9, error_w = sqrt(0.363), error_v_sd = 0.05)
summary(sim_tune_statistics(gu_et_al_g2))
knitr::opts_chunk$set(echo = TRUE)
################
##Load Libraries
################
library(glmnet)
library(tidyverse)
library(keras)
library(ggplot2)
library(forecast)
library(rlist)
library(plm)
library(Metrics)
library(ranger)
library(caret)
#Parallel Computing
library(foreach)
library(doFuture)
#Registering
registerDoFuture()
plan(multisession)
set.seed(27935248)
sim_panel_data <- function(sim_N,
char_rho_a, char_rho_b,
cross_corr, A_matrix, xt_multi, g_function, theta,
#Error Parameters
error_sv, error_ep_sd, error_omega, error_gamma, error_w, error_v_sd) {
sim_list <- foreach(i = (1:sim_N)) %dopar% {
# Set Seed for each worker so that it is reproducible
set.seed(27925248 + i)
sim <- list(panel = 0, statistics = 0)
C_bar <- gen_C_bar(char_rho_a, char_rho_b)
C_hat <- gen_C_hat(C_bar)
if (cross_corr == 0) {
C <- gen_C(C_bar)
}
else {
C <- gen_C(C_hat)
}
if (xt_multi == 1) {
xt <- gen_xt(A_matrix)
}
else {
xt <- gen_xt_univariate()
}
#Generate the true underlying factors first
g_factor_panel <- gen_g_factor_panel(g_function, C, xt)
#Then pass them through to multiply them by theta to get g()
g_panel <- gen_g_panel(g_factor_panel, theta)
#Generate the errors
error <- gen_error(sv = error_sv, ep_sd = error_ep_sd, omega = error_omega, gamma = error_gamma, w = error_w, C, v_sd = error_v_sd)
#rt panel
rt_panel <- g_panel + error
z_panel <- gen_predictor_z(C, xt)
sim$panel <- bind_rt_predictor(rt_panel, z_panel)
sim$statistics <- panel_tune_stats(rt_panel, g_panel, g_factor_panel)
sim
}
return(sim_list)
}
N <- 200
P_c <- 100
Time <- 180
#Number of realizations
simN <- 30
sim_panel_data <- function(sim_N,
char_rho_a, char_rho_b,
cross_corr, A_matrix, xt_multi, g_function, theta,
#Error Parameters
error_sv, error_ep_sd, error_omega, error_gamma, error_w, error_v_sd) {
sim_list <- foreach(i = (1:sim_N)) %dopar% {
# Set Seed for each worker so that it is reproducible
set.seed(27925248 + i)
sim <- list(panel = 0, statistics = 0)
C_bar <- gen_C_bar(char_rho_a, char_rho_b)
C_hat <- gen_C_hat(C_bar)
if (cross_corr == 0) {
C <- gen_C(C_bar)
}
else {
C <- gen_C(C_hat)
}
if (xt_multi == 1) {
xt <- gen_xt(A_matrix)
}
else {
xt <- gen_xt_univariate()
}
#Generate the true underlying factors first
g_factor_panel <- gen_g_factor_panel(g_function, C, xt)
#Then pass them through to multiply them by theta to get g()
g_panel <- gen_g_panel(g_factor_panel, theta)
#Generate the errors
error <- gen_error(sv = error_sv, ep_sd = error_ep_sd, omega = error_omega, gamma = error_gamma, w = error_w, C, v_sd = error_v_sd)
#rt panel
rt_panel <- g_panel + error
z_panel <- gen_predictor_z(C, xt)
sim$panel <- bind_rt_predictor(rt_panel, z_panel)
sim$statistics <- panel_tune_stats(rt_panel, g_panel, g_factor_panel)
sim
}
return(sim_list)
}
gu_et_al_g1 <- sim_panel_data(simN,
char_rho_a = 0.9, char_rho_b = 1,
cross_corr = 0, A1, xt_multi = 0, g_function = "g1", theta = matrix(c(0.02, 0.02, 0.02), nrow = 1),
error_sv = 0, error_ep_sd = 0.05,
error_omega = -0.736, error_gamma = 0.9, error_w = sqrt(0.363), error_v_sd = 0.05)
summary(sim_tune_statistics(gu_et_al_g1))
gu_et_al_g1 <- sim_panel_data(simN,
char_rho_a = 0.5, char_rho_b = 5,
cross_corr = 0, A1, xt_multi = 0, g_function = "g1", theta = matrix(c(0.02, 0.02, 0.02), nrow = 1),
error_sv = 0, error_ep_sd = 0.05,
error_omega = -0.736, error_gamma = 0.9, error_w = sqrt(0.363), error_v_sd = 0.05)
summary(sim_tune_statistics(gu_et_al_g1))
gu_et_al_g1 <- sim_panel_data(simN,
char_rho_a = 0.1, char_rho_b = 1,
cross_corr = 0, A1, xt_multi = 0, g_function = "g1", theta = matrix(c(0.02, 0.02, 0.02), nrow = 1),
error_sv = 0, error_ep_sd = 0.05,
error_omega = -0.736, error_gamma = 0.9, error_w = sqrt(0.363), error_v_sd = 0.05)
summary(sim_tune_statistics(gu_et_al_g1))
gu_et_al_g1 <- sim_panel_data(simN,
char_rho_a = 0.5, char_rho_b = 0.5,
cross_corr = 0, A1, xt_multi = 0, g_function = "g1", theta = matrix(c(0.02, 0.02, 0.02), nrow = 1),
error_sv = 0, error_ep_sd = 0.05,
error_omega = -0.736, error_gamma = 0.9, error_w = sqrt(0.363), error_v_sd = 0.05)
rm(gu_et_al_g1)
gu_et_al_g1 <- sim_panel_data(simN,
char_rho_a = 0.5, char_rho_b = 0.5,
cross_corr = 0, A1, xt_multi = 0, g_function = "g1", theta = matrix(c(0.02, 0.02, 0.02), nrow = 1),
error_sv = 0, error_ep_sd = 0.05,
error_omega = -0.736, error_gamma = 0.9, error_w = sqrt(0.363), error_v_sd = 0.05)
gu_et_al_g1 <- sim_panel_data(simN,
char_rho_a = 0.5, char_rho_b = 1,
cross_corr = 0, A1, xt_multi = 0, g_function = "g1", theta = matrix(c(0.02, 0.02, 0.02), nrow = 1),
error_sv = 0, error_ep_sd = 0.05,
error_omega = -0.736, error_gamma = 0.9, error_w = sqrt(0.363), error_v_sd = 0.05)
knitr::opts_chunk$set(echo = TRUE)
################
##Load Libraries
################
library(glmnet)
library(tidyverse)
library(keras)
library(ggplot2)
library(forecast)
library(rlist)
library(plm)
library(Metrics)
library(tensorflow)
library(quantreg)
library(randomForestSRC)
library(hqreg)
library(caret)
#Parallel Computing
library(foreach)
library(doFuture)
#Registering
registerDoFuture()
plan(multisession)
variable_importance_list <- rep(list(0), 3)
for (set in 1:3) {
test <- pooled_panel %>%
filter(time %in% timeSlices[[set]]$test)
test_x <- test[4:ncol(test)]
test_x_zero <- test_x
test_x_zero[1] <- 0
variable_importance <- data.frame(variable = colnames(test_x)[1], importance = (
R2(predict(LM_stats_mae[[set]]$model, newdata = test_x), test$rt, form = "traditional") -
R2(predict(LM_stats_mae[[set]]$model, newdata = test_x_zero), test$rt, form = "traditional")
)
)
for (i in 2:ncol(test_x)) {
test_x_zero <- test_x
test_x_zero[i] <- 0
variable_importance <- rbind(variable_importance,
data.frame(variable = colnames(test_x)[i],
importance = (R2(predict(LM_stats_mae[[set]]$model, newdata = test_x), test$rt, form = "traditional") -
R2(predict(LM_stats_mae[[set]]$model, newdata = test_x_zero), test$rt, form = "traditional")
)
)
)
}
variable_importance_list[[set]] <- variable_importance
}
variable_importance_list[[1]]
ggplot(variable_importance_list[[1]]) +
geom_point(aes(x = variable, y = importance)) +
theme(axis.text.x = element_text(angle = 90))
lm_variable_importance <- function(pooled_panel, timeSlices, model_fit_stats) {
variable_importance_list <- rep(list(0), 3)
for (set in 1:3) {
test <- pooled_panel %>%
filter(time %in% timeSlices[[set]]$test)
test_x <- test[4:ncol(test)]
test_x_zero <- test_x
test_x_zero[1] <- 0
variable_importance <- data.frame(variable = colnames(test_x)[1], importance = (
R2(predict(model_fit_stats[[set]]$model, newdata = test_x), test$rt, form = "traditional") -
R2(predict(model_fit_stats[[set]]$model, newdata = test_x_zero), test$rt, form = "traditional")
)
)
for (i in 2:ncol(test_x)) {
test_x_zero <- test_x
test_x_zero[i] <- 0
variable_importance <- rbind(variable_importance,
data.frame(variable = colnames(test_x)[i],
importance = (R2(predict(model_fit_stats[[set]]$model, newdata = test_x), test$rt, form = "traditional") -
R2(predict(model_fit_stats[[set]]$model, newdata = test_x_zero), test$rt, form = "traditional")
)
)
)
}
variable_importance_list[[set]] <- variable_importance
}
variable_importance_list
}
lm_mae_importance <- lm_variable_importance(pooled_panel, timeSlices, LM_stats_mae)
variable_importance_list[[1]]
lm_mae_importance[[1]]
lm_mae_importance[[1]] %>%
sort
?dplyr
lm_mae_importance[[1]] %>%
arrange(importance)
lm_mse_importance <- lm_variable_importance(pooled_panel, timeSlices, LM_stats_mse)
lm_mse_importance[[1]] %>%
arrange(importance)
object.size(pooled_panel)
?rfsrc
knitr::opts_chunk$set(echo = TRUE)
################
##Load Libraries
################
library(glmnet)
library(tidyverse)
library(keras)
library(ggplot2)
library(forecast)
library(rlist)
library(plm)
library(Metrics)
library(tensorflow)
library(quantreg)
library(randomForestSRC)
library(hqreg)
library(caret)
#Parallel Computing
library(foreach)
library(doFuture)
#Registering
registerDoFuture()
plan(multisession)
?rfsrc
