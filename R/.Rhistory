subsample = 1,
colsample_bytree = 1)
## Prep Data
dtrain <- xgb.DMatrix(data = as.matrix(train_list$data),
label = train_list$labels[, 1])
attr(dtrain, "errors") <- train_list$errors
## Fit
bst <- xgboost::xgb.train(params = param, data = dtrain, nrounds = 100, verbose = 1)
##
## Validation Predictions
## Note that this was originally used for the bayesian optimization of parameters
## As we are skipping that due to computational restrictions, this will also be commented out
pred <- predict(bst, newdata = xgboost::xgb.DMatrix(as.matrix(validation_list$data)),
outputmargin = TRUE, reshape=TRUE)
pred <- t(apply(pred, 1, softmax_transform))
pred
validation_forecasts <- foreach(i = 1:nrow(pred), .combine = "rbind") %do% {
pred[i, ] %*% set_1[[i]]$validation_forecasts
}
validation_forecasts <- validation_forecasts %>% t %>% c
## Test Set Predictions
pred <- predict(bst, newdata = xgboost::xgb.DMatrix(as.matrix(test_list$data)),
outputmargin = TRUE, reshape=TRUE)
pred <- t(apply(pred, 1, softmax_transform))
pred
test_forecasts <- foreach(i = 1:nrow(pred), .combine = "rbind") %do% {
pred[i, ] %*% set_1[[i]]$test_forecasts
}
test_forecasts <- test_forecasts %>% t %>% c
train_y <- pooled_panel %>%
dplyr::filter(time %in% timeSlices[[set]]$train) %>%
select(rt)
validation_y <- pooled_panel %>%
dplyr::filter(time %in% timeSlices[[set]]$validation) %>%
select(rt)
test_y <- pooled_panel %>%
dplyr::filter(time %in% timeSlices[[set]]$test) %>%
select(rt)
## Note that these forecasting methods don't really have a "training" error,
## so no in sample stats will be available
## Not a huge issue anyway, as no one cares
fforma_fit_stats_list[[set]]$loss_stats$validation_MAE <- mae(validation_y, validation_forecasts)
fforma_fit_stats_list[[set]]$loss_stats$validation_MSE <- mse(validation_y, validation_forecasts)
fforma_fit_stats_list[[set]]$loss_stats$validation_RMSE <- rmse(validation_y, validation_forecasts)
fforma_fit_stats_list[[set]]$loss_stats$validation_RSquare <- R2(validation_forecasts, validation_y,
form = "traditional")
fforma_fit_stats_list[[set]]$loss_stats$test_MAE <- mae(test_y, test_forecasts)
fforma_fit_stats_list[[set]]$loss_stats$test_MSE <- mse(test_y, test_forecasts)
fforma_fit_stats_list[[set]]$loss_stats$test_RMSE <- rmse(test_y, test_forecasts)
fforma_fit_stats_list[[set]]$loss_stats$test_RSquare <- R2(test_forecasts, test_y,
form = "traditional")
## Variable importance skipped for now as its really annoying to implement,
## and more importantly FFORMA doesn't care too much about external regressors anyway
fforma_fit_stats_list[[set]]$loss_stats$forecasts <- test_forecasts
fforma_fit_stats_list[[set]]$model <- bst
}
fforma_fit_stats_list
}
fforma <- fforma_fit_stats(pooled_panel, timeSlices)
fforma_fit_stats_list <- rep(list(0), length(timeSlices))
set <- 1
fforma_fit_stats_list[[set]] <- list(loss_stats = data.frame(train_MAE = 0, train_MSE = 0,
train_RMSE = 0, train_RSquare = 0,
validation_MAE = 0, validation_MSE = 0,
validation_RMSE = 0, validation_RSquare = 0,
test_MAE = 0, test_MSE = 0,
test_RMSE = 0, test_RSquare = 0),
forecasts = 0,
forecast_resids = 0,
model = 0,
variable_importance = 0)
## Fit all the individual models to all the time series first
fforma_fit <- fforma_fit_individual(pooled_panel, timeSlices, set)
## Using the fforma_fit object, then create the train, validation and test lists to use with XGBOOST
train_list <- pooled_panel %>%
filter(time %in% timeSlices[[1]]$train) %>%
fforma_data_list(loss_function = "mse", fforma_fit)
## Using the fforma_fit object, then create the train, validation and test lists to use with XGBOOST
train_list <- pooled_panel %>%
filter(time %in% timeSlices[[1]]$train) %>%
fforma_data_list(loss_function = "mse", fforma_fit)
validation_list <- pooled_panel %>%
filter(time %in% timeSlices[[1]]$validation) %>%
fforma_data_list(loss_function = "mse", fforma_fit)
validation_list <- pooled_panel %>%
filter(time %in% timeSlices[[1]]$validation) %>%
fforma_data_list(loss_function = "mse", fforma_fit)
test_list <- pooled_panel %>%
filter(time %in% timeSlices[[1]]$test) %>%
fforma_data_list(loss_function = "mse", fforma_fit)
#################################################################
## XGBOOST
param <- list(booster = "gbtree",
max_depth = 6, eta = 0.3, gamma = 0,
lambda = 0, alpha = 0, nthread = 12,
min_child_weight = 0.01,
num_class = max(labels),
objective = error_softmax_obj,
subsample = 1,
colsample_bytree = 1)
## Prep Data
dtrain <- xgb.DMatrix(data = as.matrix(train_list$data),
label = train_list$labels[, 1])
attr(dtrain, "errors") <- train_list$errors
## Fit
bst <- xgboost::xgb.train(params = param, data = dtrain, nrounds = 100, verbose = 1)
## Validation Predictions
## Note that this was originally used for the bayesian optimization of parameters
## As we are skipping that due to computational restrictions, this will also be commented out
pred <- predict(bst, newdata = xgboost::xgb.DMatrix(as.matrix(validation_list$data)),
outputmargin = TRUE, reshape=TRUE)
pred <- t(apply(pred, 1, softmax_transform))
pred
pred <- t(apply(pred, 1, softmax_transform))
## Validation Predictions
## Note that this was originally used for the bayesian optimization of parameters
## As we are skipping that due to computational restrictions, this will also be commented out
pred <- predict(bst, newdata = xgboost::xgb.DMatrix(as.matrix(validation_list$data)),
outputmargin = TRUE, reshape=TRUE)
pred <- t(apply(pred, 1, softmax_transform))
validation_forecasts <- foreach(i = 1:nrow(pred), .combine = "rbind") %do% {
pred[i, ] %*% set_1[[i]]$validation_forecasts
}
validation_forecasts <- validation_forecasts %>% t %>% c
## Test Set Predictions
pred <- predict(bst, newdata = xgboost::xgb.DMatrix(as.matrix(test_list$data)),
outputmargin = TRUE, reshape=TRUE)
pred <- t(apply(pred, 1, softmax_transform))
test_forecasts <- foreach(i = 1:nrow(pred), .combine = "rbind") %do% {
pred[i, ] %*% set_1[[i]]$test_forecasts
}
test_forecasts <- test_forecasts %>% t %>% c
train_y <- pooled_panel %>%
dplyr::filter(time %in% timeSlices[[set]]$train) %>%
select(rt)
validation_y <- pooled_panel %>%
dplyr::filter(time %in% timeSlices[[set]]$validation) %>%
select(rt)
test_y <- pooled_panel %>%
dplyr::filter(time %in% timeSlices[[set]]$test) %>%
select(rt)
fforma_fit_stats_list[[set]]$loss_stats$validation_MAE <- mae(validation_y, validation_forecasts)
fforma_fit_stats_list[[set]]$loss_stats$validation_MSE <- mse(validation_y, validation_forecasts)
fforma_fit_stats_list[[set]]$loss_stats$validation_RMSE <- rmse(validation_y, validation_forecasts)
train_y <- pooled_panel %>%
dplyr::filter(time %in% timeSlices[[set]]$train) %>%
select(rt) %>%
c
validation_y <- pooled_panel %>%
dplyr::filter(time %in% timeSlices[[set]]$validation) %>%
select(rt) %>%
c
test_y <- pooled_panel %>%
dplyr::filter(time %in% timeSlices[[set]]$test) %>%
select(rt) %>%
c
fforma_fit_stats_list[[set]]$loss_stats$validation_MAE <- mae(validation_y, validation_forecasts)
validation_y <- pooled_panel %>%
dplyr::filter(time %in% timeSlices[[set]]$validation) %>%
select(rt) %>%
c
validation_y <- pooled_panel %>%
dplyr::filter(time %in% timeSlices[[set]]$validation) %>%
select(rt) %>%
c()
View(validation_y)
validation_y <- pooled_panel %>%
dplyr::filter(time %in% timeSlices[[set]]$validation) %>%
select(rt)
View(validation_y)
validation_y %>% as.vector()
validation_y <- pooled_panel %>%
dplyr::filter(time %in% timeSlices[[set]]$validation) %>%
select(rt) %>%
as.vector
View(validation_y)
validation_y <- pooled_panel %>%
dplyr::filter(time %in% timeSlices[[set]]$validation) %>%
select(rt) %>%
as.vector
View(validation_y)
fforma_fit_stats_list[[set]]$loss_stats$validation_MAE <- mae(validation_y, validation_forecasts)
validation_y <- pooled_panel %>%
dplyr::filter(time %in% timeSlices[[set]]$validation) %>%
select(rt) %>%
as.vector()
validation_y <- pooled_panel %>%
dplyr::filter(time %in% timeSlices[[set]]$validation) %>%
select(rt) %>%
c()
train_y <- pooled_panel %>%
dplyr::filter(time %in% timeSlices[[set]]$train) %>%
select(rt) %>%
as.vector()
validation_y <- pooled_panel %>%
dplyr::filter(time %in% timeSlices[[set]]$validation) %>%
select(rt) %>%
as.vector()
test_y <- pooled_panel %>%
dplyr::filter(time %in% timeSlices[[set]]$test) %>%
select(rt) %>%
as.vector()
test_forecasts <- test_forecasts %>% t %>% c
fforma_fit_stats_list[[set]]$loss_stats$validation_MAE <- mae(validation_y, validation_forecasts)
validation_y <- pooled_panel %>%
dplyr::filter(time %in% timeSlices[[set]]$validation) %>%
select(rt) %>%
as.vector()
test_y <- pooled_panel %>%
dplyr::filter(time %in% timeSlices[[set]]$test) %>%
select(rt) %>%
as.vector()
fforma_fit_stats_list[[set]]$loss_stats$validation_MAE <- mae(validation_y, validation_forecasts)
fforma_fit_stats_list[[set]]$loss_stats$validation_MAE <- mae(validation_y$rt, validation_forecasts)
fforma_fit_stats_list[[set]]$loss_stats$validation_MAE <- mae(validation_y$rt, validation_forecasts)
fforma_fit_stats_list[[set]]$loss_stats$validation_MSE <- mse(validation_y$rt, validation_forecasts)
fforma_fit_stats_list[[set]]$loss_stats$validation_RMSE <- rmse(validation_y$rt, validation_forecasts)
fforma_fit_stats_list[[set]]$loss_stats$validation_RSquare <- R2(validation_forecasts, validation_y$rt,
form = "traditional")
fforma_fit_stats_list[[set]]$loss_stats$test_MAE <- mae(test_y$rt, test_forecasts)
fforma_fit_stats_list[[set]]$loss_stats$test_MSE <- mse(test_y$rt, test_forecasts)
fforma_fit_stats_list[[set]]$loss_stats$test_RMSE <- rmse(test_y$rt, test_forecasts)
fforma_fit_stats_list[[set]]$loss_stats$test_RSquare <- R2(test_forecasts, test_y$rt,
form = "traditional")
fforma_fit_stats_list[[set]]$loss_stats$forecasts <- test_forecasts
fforma_fit_stats_list[[set]]$model <- bst
fforma_fit_stats_list[[set]]$loss_stats$forecasts <- test_forecasts
fforma_fit_stats_list[[set]]$loss_stats$forecasts <- test_forecasts %>% as.vector()
test_forecasts %>% as.vector()
fforma_fit_stats_list[[set]]$loss_stats$forecasts <- test_forecasts %>% as.vector()
fforma_fit_stats_list[[set]]$loss_stats$forecasts <- test_forecasts %>% as.vector()
fforma_fit_stats_list[[set]]$forecasts <- test_forecasts %>% as.vector()
fforma_fit_stats <- function(pooled_panel, timeSlices) {
fforma_fit_stats_list <- rep(list(0), length(timeSlices))
for (set in 1:length(fforma_fit_stats)) {
fforma_fit_stats_list[[set]] <- list(loss_stats = data.frame(train_MAE = 0, train_MSE = 0,
train_RMSE = 0, train_RSquare = 0,
validation_MAE = 0, validation_MSE = 0,
validation_RMSE = 0, validation_RSquare = 0,
test_MAE = 0, test_MSE = 0,
test_RMSE = 0, test_RSquare = 0),
forecasts = 0,
forecast_resids = 0,
model = 0,
variable_importance = 0)
## Fit all the individual models to all the time series first
fforma_fit <- fforma_fit_individual(pooled_panel, timeSlices, set)
## Using the fforma_fit object, then create the train, validation and test lists to use with XGBOOST
train_list <- pooled_panel %>%
filter(time %in% timeSlices[[1]]$train) %>%
fforma_data_list(loss_function = "mse", fforma_fit)
validation_list <- pooled_panel %>%
filter(time %in% timeSlices[[1]]$validation) %>%
fforma_data_list(loss_function = "mse", fforma_fit)
test_list <- pooled_panel %>%
filter(time %in% timeSlices[[1]]$test) %>%
fforma_data_list(loss_function = "mse", fforma_fit)
#################################################################
## XGBOOST
param <- list(booster = "gbtree",
max_depth = 6, eta = 0.3, gamma = 0,
lambda = 0, alpha = 0, nthread = 12,
min_child_weight = 0.01,
num_class = max(labels),
objective = error_softmax_obj,
subsample = 1,
colsample_bytree = 1)
## Prep Data
dtrain <- xgb.DMatrix(data = as.matrix(train_list$data),
label = train_list$labels[, 1])
attr(dtrain, "errors") <- train_list$errors
## Fit
bst <- xgboost::xgb.train(params = param, data = dtrain, nrounds = 100, verbose = 1)
##
## Validation Predictions
## Note that this was originally used for the bayesian optimization of parameters
## As we are skipping that due to computational restrictions, this will also be commented out
pred <- predict(bst, newdata = xgboost::xgb.DMatrix(as.matrix(validation_list$data)),
outputmargin = TRUE, reshape=TRUE)
pred <- t(apply(pred, 1, softmax_transform))
validation_forecasts <- foreach(i = 1:nrow(pred), .combine = "rbind") %do% {
pred[i, ] %*% set_1[[i]]$validation_forecasts
}
validation_forecasts <- validation_forecasts %>% t %>% c
## Test Set Predictions
pred <- predict(bst, newdata = xgboost::xgb.DMatrix(as.matrix(test_list$data)),
outputmargin = TRUE, reshape=TRUE)
pred <- t(apply(pred, 1, softmax_transform))
test_forecasts <- foreach(i = 1:nrow(pred), .combine = "rbind") %do% {
pred[i, ] %*% set_1[[i]]$test_forecasts
}
test_forecasts <- test_forecasts %>% t %>% c
train_y <- pooled_panel %>%
dplyr::filter(time %in% timeSlices[[set]]$train) %>%
select(rt)
validation_y <- pooled_panel %>%
dplyr::filter(time %in% timeSlices[[set]]$validation) %>%
select(rt)
test_y <- pooled_panel %>%
dplyr::filter(time %in% timeSlices[[set]]$test) %>%
select(rt)
## Note that these forecasting methods don't really have a "training" error,
## so no in sample stats will be available
## Not a huge issue anyway, as no one cares
fforma_fit_stats_list[[set]]$loss_stats$validation_MAE <- mae(validation_y$rt, validation_forecasts)
fforma_fit_stats_list[[set]]$loss_stats$validation_MSE <- mse(validation_y$rt, validation_forecasts)
fforma_fit_stats_list[[set]]$loss_stats$validation_RMSE <- rmse(validation_y$rt, validation_forecasts)
fforma_fit_stats_list[[set]]$loss_stats$validation_RSquare <- R2(validation_forecasts, validation_y$rt,
form = "traditional")
fforma_fit_stats_list[[set]]$loss_stats$test_MAE <- mae(test_y$rt, test_forecasts)
fforma_fit_stats_list[[set]]$loss_stats$test_MSE <- mse(test_y$rt, test_forecasts)
fforma_fit_stats_list[[set]]$loss_stats$test_RMSE <- rmse(test_y$rt, test_forecasts)
fforma_fit_stats_list[[set]]$loss_stats$test_RSquare <- R2(test_forecasts, test_y$rt,
form = "traditional")
## Variable importance skipped for now as its really annoying to implement,
## and more importantly FFORMA doesn't care too much about external regressors anyway
fforma_fit_stats_list[[set]]$forecasts <- test_forecasts %>% as.vector()
fforma_fit_stats_list[[set]]$model <- bst
}
fforma_fit_stats_list
}
fforma <- fforma_fit_stats(pooled_panel, timeSlices)
View(fforma)
fforma_fit_stats <- function(pooled_panel, timeSlices) {
fforma_fit_stats_list <- rep(list(0), length(timeSlices))
for (set in 1:length(fforma_fit_stats)) {
fforma_fit_stats_list[[set]] <- list(loss_stats = data.frame(train_MAE = 0, train_MSE = 0,
train_RMSE = 0, train_RSquare = 0,
validation_MAE = 0, validation_MSE = 0,
validation_RMSE = 0, validation_RSquare = 0,
test_MAE = 0, test_MSE = 0,
test_RMSE = 0, test_RSquare = 0),
forecasts = 0,
forecast_resids = 0,
model = 0,
variable_importance = 0)
## Fit all the individual models to all the time series first
fforma_fit <- fforma_fit_individual(pooled_panel, timeSlices, set)
## Using the fforma_fit object, then create the train, validation and test lists to use with XGBOOST
train_list <- pooled_panel %>%
filter(time %in% timeSlices[[set]]$train) %>%
fforma_data_list(loss_function = "mse", fforma_fit)
validation_list <- pooled_panel %>%
filter(time %in% timeSlices[[set]]$validation) %>%
fforma_data_list(loss_function = "mse", fforma_fit)
test_list <- pooled_panel %>%
filter(time %in% timeSlices[[set]]$test) %>%
fforma_data_list(loss_function = "mse", fforma_fit)
#################################################################
## XGBOOST
param <- list(booster = "gbtree",
max_depth = 6, eta = 0.3, gamma = 0,
lambda = 0, alpha = 0, nthread = 12,
min_child_weight = 0.01,
num_class = max(labels),
objective = error_softmax_obj,
subsample = 1,
colsample_bytree = 1)
## Prep Data
dtrain <- xgb.DMatrix(data = as.matrix(train_list$data),
label = train_list$labels[, 1])
attr(dtrain, "errors") <- train_list$errors
## Fit
bst <- xgboost::xgb.train(params = param, data = dtrain, nrounds = 100, verbose = 1)
##
## Validation Predictions
## Note that this was originally used for the bayesian optimization of parameters
## As we are skipping that due to computational restrictions, this will also be commented out
pred <- predict(bst, newdata = xgboost::xgb.DMatrix(as.matrix(validation_list$data)),
outputmargin = TRUE, reshape=TRUE)
pred <- t(apply(pred, 1, softmax_transform))
validation_forecasts <- foreach(i = 1:nrow(pred), .combine = "rbind") %do% {
pred[i, ] %*% set_1[[i]]$validation_forecasts
}
validation_forecasts <- validation_forecasts %>% t %>% c
## Test Set Predictions
pred <- predict(bst, newdata = xgboost::xgb.DMatrix(as.matrix(test_list$data)),
outputmargin = TRUE, reshape=TRUE)
pred <- t(apply(pred, 1, softmax_transform))
test_forecasts <- foreach(i = 1:nrow(pred), .combine = "rbind") %do% {
pred[i, ] %*% set_1[[i]]$test_forecasts
}
test_forecasts <- test_forecasts %>% t %>% c
train_y <- pooled_panel %>%
dplyr::filter(time %in% timeSlices[[set]]$train) %>%
select(rt)
validation_y <- pooled_panel %>%
dplyr::filter(time %in% timeSlices[[set]]$validation) %>%
select(rt)
test_y <- pooled_panel %>%
dplyr::filter(time %in% timeSlices[[set]]$test) %>%
select(rt)
## Note that these forecasting methods don't really have a "training" error,
## so no in sample stats will be available
## Not a huge issue anyway, as no one cares
fforma_fit_stats_list[[set]]$loss_stats$validation_MAE <- mae(validation_y$rt, validation_forecasts)
fforma_fit_stats_list[[set]]$loss_stats$validation_MSE <- mse(validation_y$rt, validation_forecasts)
fforma_fit_stats_list[[set]]$loss_stats$validation_RMSE <- rmse(validation_y$rt, validation_forecasts)
fforma_fit_stats_list[[set]]$loss_stats$validation_RSquare <- R2(validation_forecasts, validation_y$rt,
form = "traditional")
fforma_fit_stats_list[[set]]$loss_stats$test_MAE <- mae(test_y$rt, test_forecasts)
fforma_fit_stats_list[[set]]$loss_stats$test_MSE <- mse(test_y$rt, test_forecasts)
fforma_fit_stats_list[[set]]$loss_stats$test_RMSE <- rmse(test_y$rt, test_forecasts)
fforma_fit_stats_list[[set]]$loss_stats$test_RSquare <- R2(test_forecasts, test_y$rt,
form = "traditional")
## Variable importance skipped for now as its really annoying to implement,
## and more importantly FFORMA doesn't care too much about external regressors anyway
fforma_fit_stats_list[[set]]$forecasts <- test_forecasts %>% as.vector()
fforma_fit_stats_list[[set]]$model <- bst
}
fforma_fit_stats_list
}
fforma <- fforma_fit_stats(pooled_panel, timeSlices)
fforma[[1]]
fforma[[1]]$loss_stats
fforma[[2]]$loss_stats
fforma_fit_stats <- function(pooled_panel, timeSlices) {
fforma_fit_stats_list <- rep(list(0), length(timeSlices))
for (set in 1:length(fforma_fit_stats_list)) {
fforma_fit_stats_list[[set]] <- list(loss_stats = data.frame(train_MAE = 0, train_MSE = 0,
train_RMSE = 0, train_RSquare = 0,
validation_MAE = 0, validation_MSE = 0,
validation_RMSE = 0, validation_RSquare = 0,
test_MAE = 0, test_MSE = 0,
test_RMSE = 0, test_RSquare = 0),
forecasts = 0,
forecast_resids = 0,
model = 0,
variable_importance = 0)
## Fit all the individual models to all the time series first
fforma_fit <- fforma_fit_individual(pooled_panel, timeSlices, set)
## Using the fforma_fit object, then create the train, validation and test lists to use with XGBOOST
train_list <- pooled_panel %>%
filter(time %in% timeSlices[[set]]$train) %>%
fforma_data_list(loss_function = "mse", fforma_fit)
validation_list <- pooled_panel %>%
filter(time %in% timeSlices[[set]]$validation) %>%
fforma_data_list(loss_function = "mse", fforma_fit)
test_list <- pooled_panel %>%
filter(time %in% timeSlices[[set]]$test) %>%
fforma_data_list(loss_function = "mse", fforma_fit)
#################################################################
## XGBOOST
param <- list(booster = "gbtree",
max_depth = 6, eta = 0.3, gamma = 0,
lambda = 0, alpha = 0, nthread = 12,
min_child_weight = 0.01,
num_class = max(labels),
objective = error_softmax_obj,
subsample = 1,
colsample_bytree = 1)
## Prep Data
dtrain <- xgb.DMatrix(data = as.matrix(train_list$data),
label = train_list$labels[, 1])
attr(dtrain, "errors") <- train_list$errors
## Fit
bst <- xgboost::xgb.train(params = param, data = dtrain, nrounds = 100, verbose = 1)
##
## Validation Predictions
## Note that this was originally used for the bayesian optimization of parameters
## As we are skipping that due to computational restrictions, this will also be commented out
pred <- predict(bst, newdata = xgboost::xgb.DMatrix(as.matrix(validation_list$data)),
outputmargin = TRUE, reshape=TRUE)
pred <- t(apply(pred, 1, softmax_transform))
validation_forecasts <- foreach(i = 1:nrow(pred), .combine = "rbind") %do% {
pred[i, ] %*% set_1[[i]]$validation_forecasts
}
validation_forecasts <- validation_forecasts %>% t %>% c
## Test Set Predictions
pred <- predict(bst, newdata = xgboost::xgb.DMatrix(as.matrix(test_list$data)),
outputmargin = TRUE, reshape=TRUE)
pred <- t(apply(pred, 1, softmax_transform))
test_forecasts <- foreach(i = 1:nrow(pred), .combine = "rbind") %do% {
pred[i, ] %*% set_1[[i]]$test_forecasts
}
test_forecasts <- test_forecasts %>% t %>% c
train_y <- pooled_panel %>%
dplyr::filter(time %in% timeSlices[[set]]$train) %>%
select(rt)
validation_y <- pooled_panel %>%
dplyr::filter(time %in% timeSlices[[set]]$validation) %>%
select(rt)
test_y <- pooled_panel %>%
dplyr::filter(time %in% timeSlices[[set]]$test) %>%
select(rt)
## Note that these forecasting methods don't really have a "training" error,
## so no in sample stats will be available
## Not a huge issue anyway, as no one cares
fforma_fit_stats_list[[set]]$loss_stats$validation_MAE <- mae(validation_y$rt, validation_forecasts)
fforma_fit_stats_list[[set]]$loss_stats$validation_MSE <- mse(validation_y$rt, validation_forecasts)
fforma_fit_stats_list[[set]]$loss_stats$validation_RMSE <- rmse(validation_y$rt, validation_forecasts)
fforma_fit_stats_list[[set]]$loss_stats$validation_RSquare <- R2(validation_forecasts, validation_y$rt,
form = "traditional")
fforma_fit_stats_list[[set]]$loss_stats$test_MAE <- mae(test_y$rt, test_forecasts)
fforma_fit_stats_list[[set]]$loss_stats$test_MSE <- mse(test_y$rt, test_forecasts)
fforma_fit_stats_list[[set]]$loss_stats$test_RMSE <- rmse(test_y$rt, test_forecasts)
fforma_fit_stats_list[[set]]$loss_stats$test_RSquare <- R2(test_forecasts, test_y$rt,
form = "traditional")
## Variable importance skipped for now as its really annoying to implement,
## and more importantly FFORMA doesn't care too much about external regressors anyway
fforma_fit_stats_list[[set]]$forecasts <- test_forecasts %>% as.vector()
fforma_fit_stats_list[[set]]$model <- bst
}
fforma_fit_stats_list
}
fforma[[1]]$loss_stats
fforma <- fforma_fit_stats(pooled_panel, timeSlices)
fforma[[1]]$loss_stats
fforma[[2]]$loss_stats
fforma[[3]]$loss_stats
fforma[[2]]$loss_stats
fforma[[3]]$loss_stats
