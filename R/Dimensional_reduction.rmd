---
title: "Dimensional Reduction"
author: "Ze Yu Zhong"
date: "27/11/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
################
##Load Libraries
################

library(speedglm)
library(tidyverse)
library(keras)
library(ggplot2)
library(forecast)
library(rlist)
library(Metrics)
library(tensorflow)
library(quantreg)
library(randomForestSRC)
library(hqreg)
library(caret)
library(tsfeatures)

## Vector arima/garch packages

library(kernlab)
library(xts)
library(tsne)
library(rmgarch)
library(marima)
library(xgboost)
library(umap)
library(uwot)

#Parallel Computing
library(foreach)
library(doFuture)
#Registering
registerDoFuture()
plan(multisession)
```

```{r}
## Load Simulated Data
pooled_panel <- readRDS("pooled_panel.rds")

## Load empirical data
empirical_panel <- readRDS("final_dataset.rds")
empirical_panel_no_interaction <- readRDS("final_dataset_no_interaction.rds")
```

```{r}
## Attempts at visualizing using PCA

## Using the entire panel
# Change tol to higher fractions to automatically choose a lower number of PCs to keep
pooled_panel_pca <- prcomp(pooled_panel[, -(1:3)], center = TRUE, scale. = TRUE, tol = 0.2)

# Plot explained variances
# Not very good at projecting into a lower dimensional space
plot(pooled_panel_pca)
summary(pooled_panel_pca)

# Unsurprisingly, not much can be seen from plotting the principal components
predict(pooled_panel_pca) %>%
  data.frame() %>%
  ggplot() +
  geom_point(aes(x = PC1, y = PC2))

##
empirical_panel_pca <- prcomp(empirical_panel[, -(1:3)], center = TRUE, scale. = TRUE, tol = 0.2)
# Goods news, empirical data responds much better to PCA projection, according to plots
# However, we still need something like ~80 components just to explain 80% of the variance
# Recalling that our time length is 90 at most (full sample), this is still no feasible
plot(empirical_panel_pca)
summary(empirical_panel_pca)

##
# Problem with this dataset: some columns are constant
col_var <- is.na(apply(empirical_panel_no_interaction, 2, var))

empirical_panel_no_interaction <- empirical_panel_no_interaction[, !col_var]

empirical_panel_no_interaction_pca <- prcomp(empirical_panel_no_interaction[, -(1:3)], 
                                             center = TRUE, scale. = TRUE, tol = 0.2)
# Using an empirical panel without interaction terms does seem to help, but not by much
plot(empirical_panel_no_interaction_pca)
summary(empirical_panel_no_interaction_pca)

############
## Focusing on univariate series

simulation_stock_id <- unique(pooled_panel$stock)
pooled_panel_uni <- pooled_panel %>%
  filter(stock == "stock_1")

pooled_panel_uni_pca <- prcomp(pooled_panel_uni[, -(1:3)], center = TRUE, scale. = TRUE, tol = 0.2)

# Very similar story on univariate series
plot(pooled_panel_uni_pca)
summary(pooled_panel_uni_pca)

empirical_stock_id <- unique(empirical_panel_no_interaction$stock)
empirical_panel_uni <- empirical_panel_no_interaction %>%
  filter(stock == empirical_stock_id[1])

# Deal with constant columns/no variance in regressors again
# Note that this immediately means this is unsuitable, as some stocks can have some variance in certain regressors, while others don't
col_var <- is.na(apply(empirical_panel_uni, 2, var))
col_var <- col_var + (apply(empirical_panel_uni, 2, var) == 0)
empirical_panel_uni <- empirical_panel_uni[, !col_var]

empirical_panel_uni_pca <- prcomp(empirical_panel_uni[, -(1:3)], center = TRUE, scale. = TRUE, tol = 0.2)
# SImilarly see that PCA is not very good at dimensional reduction, recalling that on a univariate level we only have ~ 90 observations
plot(empirical_panel_uni_pca)
summary(empirical_panel_uni_pca)
```

```{r}
## T-SNE approach
## This is not feasible for use with the entire panel, takes way too long

## Using entire panel

pooled_panel_tsne <- tsne(as.matrix(pooled_panel[, -(1:3)]))
plot(pooled_panel_tsne)

stock_series_tsne %>%
  mutate(V2 = (V2 - mean(V2))/sd(V2)) %>%
  mutate(V3 = (V3 - mean(V3))/sd(V3)) %>%
  mutate(stock = as.factor(stock)) %>%
  ggplot() +
  geom_point(aes(x = V2, y = V3, colour = stock)) +
  theme(legend.position = "none")

```

```{r}
## UMAP approach
## Not too sure what UMAP is or how it works exactly, apart from it's similar to t-SNE, and also also embed (predict) new data points
## Use the uwot package, which includes support for parallel computation of umap

### Simulated Data
pooled_panel_umap <- umap(pooled_panel[, -(1:3)],
                          n_threads = 12)

plot(pooled_panel_umap)

simulation_stock_id <- unique(pooled_panel$stock)
pooled_panel_uni <- pooled_panel %>%
  filter(stock == "stock_1")

pooled_panel_uni_umap <- umap(pooled_panel_uni[, -(1:3)],
                              n_threads = 12)
plot(pooled_panel_uni_umap)

### Empirical Data
# Problem with this dataset: some columns are constant
col_var <- is.na(apply(empirical_panel_no_interaction, 2, var))
empirical_panel_no_interaction <- empirical_panel_no_interaction[, !col_var]

empirical_panel_no_interaction_umap <- umap(empirical_panel_no_interaction[, -(1:3)],
                                            n_threads = 12)
plot(empirical_panel_no_interaction_umap)
```



