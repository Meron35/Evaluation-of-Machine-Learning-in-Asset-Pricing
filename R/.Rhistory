),
nrow = 1) %*% theta
}
#test if working
g3(C, xt, 1, 1)
#################################
#g4
#Remember that we are supposed to pass C hat through to g4
#################################
g4 <- function(C, x, i, t){
theta <- matrix(c(0.02, 0.02, 0.02), ncol = 1)
matrix(c(
C[[t]][i, 1],
C[[t]][i, 2],
C[[t]][i, 3]*t(x[t, 3])
), nrow = 1
) %*% theta
}
#test if working
g4(C_hat, xt, 1, 1)
#################################
#Function to generate entire set of C()
gen_v <- function(){
elo <- matrix(0, nrow = 3, ncol = 1)
v <- rep(list(elo), Time)
for (t in 1:Time) {
v[[t]] <- matrix(
data = rnorm(3, 0, 1),
nrow = 3, ncol = 1
)
}
}
gen_v()
rm(v)
gen_v <- function(){
elo <- matrix(0, nrow = 3, ncol = 1)
v <- rep(list(elo), Time)
for (t in 1:Time) {
v[[t]] <- matrix(
data = rnorm(3, 0, 1),
nrow = 3, ncol = 1
)
}
return(v)
}
gen_v()
gen_Beta <- function(){
#Empty Matrix Init
eln <- matrix(0, nrow = N, ncol = 3)
Beta <- rep(list(eln), Time)
for (t in 1:Time) {
Beta[[t]] <- C[[t]][, 1:3]
}
return(Beta)
}
gen_error <- function(){
##Generate Sigma first
sigma2 <- rep(list(0), Time+1)
sigma2[[1]] <- omega + w
for (t in 1:Time) {
sigma2[[t+1]] <- omega + gamma*sigma2[[t]] + w
}
sigma2[[1]] <- NULL
##Generate Errors
error <- rep(
list(
matrix(
0, nrow = N, ncol = 1
)
), Time
)
for (t in 1:Time){
for (i in 1:N) {
error[[t]][i] <- exp(sqrt(sigma2[[t]])/2)*rnorm(1, 0, 1)
}
}
return(error)
}
gen_error()
omega <- -0.736
gamma <- 0.90
w <- sqrt(0.363)
gen_error()
gen_error <- function(){
##Generate Sigma first
sigma2 <- rep(list(0), Time+1)
sigma2[[1]] <- omega + w
for (t in 1:Time) {
sigma2[[t+1]] <- omega + gamma*sigma2[[t]] + w
}
sigma2[[1]] <- NULL
##Generate Errors
error <- rep(
list(
matrix(
0, nrow = N, ncol = 1
)
), Time
)
for (t in 1:Time){
for (i in 1:N) {
error[[t]][i] <- exp(sqrt(abs(sigma2[[t]]))/2)*rnorm(1, 0, 1)
}
}
return(error)
}
gen_error()
A1xt <- gen_xt(A1, xt)
Beta <- gen_Beta()
v <- gen_v
error <- gen_error
for (t in 1:Time) {
for (i in 1:N){
g1(C, A1xt, i, t) + Beta[[t+1]] %*% v[[t+1]] + error[[t+1]][i]
}
}
Beta <- gen_Beta()
v <- gen_v()
error <- gen_error()
for (t in 1:Time) {
for (i in 1:N){
g1(C, A1xt, i, t) + Beta[[t+1]] %*% v[[t+1]] + error[[t+1]][i]
}
}
Beta[[1]]
v[[1]]
Beta[[1]] %*% v[[1]]
elp <- matrix(0, nrow = N, ncol = 1)
r <- rep(list(elp), Time+1)
for (t in 1:Time+1) {
for (i in 1:N){
g1(C, A1xt, i, t) + Beta[[t+1]] %*% v[[t+1]] + error[[t+1]][i]
}
}
Beta[[1+1]]
v[[1+1]]
Beta[[1+1]] %*% v[[1+1]]
error[[1]]
g1(C, A1xt, 1, 1)
for (t in 1:Time+1) {
for (i in 1:N){
g1(C, A1xt, i, t) + Beta[[t+1]][i] %*% v[[t+1]][i] + error[[t+1]][i]
}
}
##########################
##Generate Datasets
##With 3 specifications of A and 4 specifications of g(), there should be 3*4 = 12 different sets of data in total
##########################
###########
##Function to generate Beta, i,t
###########
gen_Beta <- function(){
#Empty Matrix Init
eln <- matrix(0, nrow = N, ncol = 3)
Beta <- rep(list(eln), Time+1)
for (t in 1:Time+1) {
Beta[[t]] <- C[[t]][, 1:3]
}
return(Beta)
}
###
##Function to generate v vector of errors
###
gen_v <- function(){
#Empty Matrix Init
elo <- matrix(0, nrow = 3, ncol = 1)
v <- rep(list(elo), Time+1)
for (t in 1:Time+1) {
v[[t]] <- matrix(
data = rnorm(3, 0, 1),
nrow = 3, ncol = 1
)
}
return(v)
}
#############################
##Error Structure
#############################
##Specify omega, gamma and w
omega <- -0.736
gamma <- 0.90
w <- sqrt(0.363)
##
#############################
##Function to generate errors
#############################
gen_error <- function(){
##Generate Sigma first
##Sigma2 can be negative, check with David
sigma2 <- rep(list(0), Time+1)
sigma2[[1]] <- omega + w
for (t in 1:Time+1) {
sigma2[[t+1]] <- omega + gamma*sigma2[[t]] + w
}
sigma2[[1]] <- NULL
##Generate Errors
error <- rep(
list(
matrix(
0, nrow = N, ncol = 1
)
), Time+1
)
for (t in 1:Time+1){
for (i in 1:N) {
error[[t]][i] <- exp(sqrt(abs(sigma2[[t]]))/2)*rnorm(1, 0, 1)
}
}
return(error)
}
A1xt <- gen_xt(A1, xt)
Beta <- gen_Beta()
#Check
gen_Beta()
###################
##characteristics C
###################
#empty matrix
elm <- matrix(
data = 0, nrow = N, ncol = P_c
)
C_bar <- rep(list(elm), Time + 1 + 1)
for (t in 1:Time+1) {
for (j in 1:P_c) {
rho <- runif(1, 1/2, 1)
for (i in 1:N) {
C_bar[[t+1]][i, j] <- C_bar[[t]][i, j]*rho + rnorm(1, 0, 1)
}
}
}
#Remove initial
C_bar[[1]] <- NULL
######################
##B and lambda matrix
######################
Lambda <- matrix(
data = rnorm(N*4, 0, 1),
nrow = N, ncol = 4
)
B <- (Lambda)%*%t(Lambda)
B <- B + 1/10*diag(nrow = nrow(B))
#######################################
##Transform into correlation matrix W
#######################################
W <- diag(B)^(-1/2)*B*diag(B)^(-1/2)
C_hat <- rep(list(elm), Time + 1)
for (t in 1:Time+1) {
C_hat[[t]] <- W %*% C_bar[[t]]
}
#Generate final "observed" C
C <- rep(list(elm), Time+1)
for (t in 1:Time+1) {
C[[t]] <- (2/(N*P_c+1))*(
rank(C_bar[[t]])
) - matrix(
data = 1, nrow = N, ncol = P_c
)
}
########################
##xt set up
########################
########################
##Specify A Matrices
########################
A1 <- matrix(c(
0.95, 0, 0,
0, 0.95, 0,
0, 0, 0.95),
nrow = 3, ncol = 3
)
A2 <- matrix(c(
1, 0, 0.25,
0, 0.95, 0,
0.25, 0, 0.95),
nrow = 3, ncol = 3
)
A3 <- matrix(c(
0.99, 0.2, 0.1,
0.2, 0.90, -0.3,
0.1, -0.3, -0.99),
nrow = 3, ncol = 3
)
xt <- data.frame(x1 = c(0:179),
x2 = c(0:179),
x3 = c(0:179)
)
####
###Function to Generate xt series
####
gen_xt <- function(A, xt){
Axt <- xt
for (i in 1:Time+1 - 1) {
ut <- rnorm(3, mean = 0, sd = 1)
Axt[1+i,] <- Axt[i,] + ut
}
return(Axt)
}
###
##Function to plot xt
###
plot_xt <- function(xt){
xt_tidy <- cbind(t = c(1:Time+1), xt)
xt_tidy <- xt_tidy %>%
gather(series, value, -t)
ggplot(data = xt_tidy) +
geom_line(aes(x = t, y = value, colour = series))
}
#Check
gen_Beta()
C[[1]]
C_bar[[1]]
C_bar <- rep(list(elm), Time + 1 + 1)
for (t in 1:Time+1+1) {
for (j in 1:P_c) {
rho <- runif(1, 1/2, 1)
for (i in 1:N) {
C_bar[[t+1]][i, j] <- C_bar[[t]][i, j]*rho + rnorm(1, 0, 1)
}
}
}
C_bar <- rep(list(elm), Time + 1 + 1)
for (t in 1:Time+1) {
for (j in 1:P_c) {
rho <- runif(1, 1/2, 1)
for (i in 1:N) {
C_bar[[t+1]][i, j] <- C_bar[[t]][i, j]*rho + rnorm(1, 0, 1)
}
}
}
C_bar[[1]] <- NULL
C_bar[[1]]
C_bar[[2]]
C_bar <- rep(list(elm), Time + 1 + 1)
for (t in 1:Time+1) {
for (j in 1:P_c) {
rho <- runif(1, 1/2, 1)
for (i in 1:N) {
C_bar[[t+1]][i, j] <- C_bar[[t]][i, j]*rho + rnorm(1, 0, 1)
}
}
}
C_bar[[2]]
C_bar[[1]]
C_bar <- rep(list(elm), Time + 1 + 1)
for (t in 2:Time+1+1) {
for (j in 1:P_c) {
rho <- runif(1, 1/2, 1)
for (i in 1:N) {
C_bar[[t]][i, j] <- C_bar[[t-1]][i, j]*rho + rnorm(1, 0, 1)
}
}
}
C_bar[[2]]
for (t in 2:Time+1+1) {
for (j in 1:P_c) {
rho <- runif(1, 1/2, 1)
for (i in 1:N) {
C_bar[[t]][i, j] <- (C_bar[[t-1]][i, j]*rho + rnorm(1, 0, 1))
}
}
}
C_bar[[2]]
C_bar[[0]]
C_bar[[1]] <- matrix(
data = rnorm(N*P_c, 0, 1),
nrow = N, ncol = P_c
)
C_bar <- rep(list(elm), Time + 1)
C_bar[[1]] <- matrix(
data = rnorm(N*P_c, 0, 1),
nrow = N, ncol = P_c
)
for (t in 1:Time+1) {
for (j in 1:P_c) {
rho <- runif(1, 1/2, 1)
for (i in 1:N) {
C_bar[[t+1]][i, j] <- (C_bar[[t]][i, j]*rho + rnorm(1, 0, 1))
}
}
}
C_bar <- rep(list(elm), Time + 1)
C_bar[[1]] <- matrix(
data = rnorm(N*P_c, 0, 1),
nrow = N, ncol = P_c
)
for (t in 2:Time+1) {
for (j in 1:P_c) {
rho <- runif(1, 1/2, 1)
for (i in 1:N) {
C_bar[[t]][i, j] <- (C_bar[[t-1]][i, j]*rho + rnorm(1, 0, 1))
}
}
}
Lambda <- matrix(
data = rnorm(N*4, 0, 1),
nrow = N, ncol = 4
)
B <- (Lambda)%*%t(Lambda)
B <- B + 1/10*diag(nrow = nrow(B))
W <- diag(B)^(-1/2)*B*diag(B)^(-1/2)
C_hat <- rep(list(elm), Time + 1)
for (t in 1:Time+1) {
C_hat[[t]] <- W %*% C_bar[[t]]
}
C <- rep(list(elm), Time+1)
for (t in 1:Time+1) {
C[[t]] <- (2/(N*P_c+1))*(
rank(C_bar[[t]])
) - matrix(
data = 1, nrow = N, ncol = P_c
)
}
########################
##xt set up
########################
########################
##Specify A Matrices
########################
A1 <- matrix(c(
0.95, 0, 0,
0, 0.95, 0,
0, 0, 0.95),
nrow = 3, ncol = 3
)
A2 <- matrix(c(
1, 0, 0.25,
0, 0.95, 0,
0.25, 0, 0.95),
nrow = 3, ncol = 3
)
A3 <- matrix(c(
0.99, 0.2, 0.1,
0.2, 0.90, -0.3,
0.1, -0.3, -0.99),
nrow = 3, ncol = 3
)
xt <- data.frame(x1 = c(0:179),
x2 = c(0:179),
x3 = c(0:179)
)
####
###Function to Generate xt series
####
gen_xt <- function(A, xt){
Axt <- xt
for (i in 1:Time+1 - 1) {
ut <- rnorm(3, mean = 0, sd = 1)
Axt[1+i,] <- Axt[i,] + ut
}
return(Axt)
}
###
##Function to plot xt
###
plot_xt <- function(xt){
xt_tidy <- cbind(t = c(1:Time+1), xt)
xt_tidy <- xt_tidy %>%
gather(series, value, -t)
ggplot(data = xt_tidy) +
geom_line(aes(x = t, y = value, colour = series))
}
#test if working
g1(C, xt, 1, 1)
C_bar[[1]]
C[[1]]
C[[2]]
for (t in 1:Time+1) {
C[[t]] <- (2/(N*P_c+1))*(
rank(C_bar[[t]])
) - matrix(
data = 1, nrow = N, ncol = P_c
)
}
C[[1]]
rank(C_bar[[1]])
(2/(N*P_c+1))*(
rank(C_bar[[1]])
)
(2/(N*P_c+1))*(
rank(C_bar[[1]])
) - matrix(
data = 1, nrow = N, ncol = P_c
)
C <- rep(list(elm), Time+1)
for (t in 1:Time+1) {
C[[t]] <- (2/(N*P_c+1))*(
rank(C_bar[[t]])
) - matrix(
data = 1, nrow = N, ncol = P_c
)
}
C[[1]]
(2/(N*P_c+1))*(
rank(C_bar[[1]])
) - matrix(
data = 1, nrow = N, ncol = P_c
)
C[[1]] <- (2/(N*P_c+1))*(
rank(C_bar[[1]])
) - matrix(
data = 1, nrow = N, ncol = P_c
)
C[[1]]
for (t in 1:Time+1) {
C[[t]] <- (2/(N*P_c+1))*(
rank(C_bar[[t]])
) - matrix(
data = 1, nrow = N, ncol = P_c
)
}
C[[1]]
C[[2]]
