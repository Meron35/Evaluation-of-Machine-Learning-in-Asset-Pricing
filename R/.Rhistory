#Individual return R squared
rt_id_tune_df <- data.frame(
stock = c(1:N),
rsquare = c(1:N)
)
for (i in 1:N) {
rt_id_tune_panel <- rt_cross_tune_panel %>%
filter(stock == i)
rt_id_tune_df$rsquare[i] <- r_squared(rt_cross_tune_panel$g, rt_cross_tune_panel$return)
}
#Return mean of each individual rsquared
mean(rt_id_tune_df$rsquare)
######################################################################################
#Calculate Annualized Volatility
#Annualized volatility = calculate volatility (via standard deviation) for the monthly returns, then annualize it by multiplying it by sqrt(12) for 12 months in a year
vol_tune_df <- data.frame(
stock = c(1:N),
annual_vol = c(1:N)
)
for (i in 1:N) {
vol_tune_panel <- rt_cross_tune_panel %>%
filter(stock == i)
vol_tune_df$annual_vol[i] <- sd(vol_tune_panel$return) * sqrt(12)
}
#Return the mean annualized volatility
#Want this around 30%
mean(vol_tune_df$annual_vol)
######################################################################################
#Cross Sectional R Squared for a given time period
rt_cross_section <- data.frame(
time = rep(0, Time),
rsquare = rep(0, Time)
)
for (t in 2:(Time+1)) {
rt_cross_section$time <- t
rt_cross_tune_panel_cross_section <- rt_cross_tune_panel %>%
filter(time == t)
rt_cross_section$rsquare[t-1] <- r_squared(rt_cross_tune_panel_cross_section$g, rt_cross_tune_panel_cross_section$return)
}
mean(rt_cross_section$rsquare)
######################################################################################
#Predictive R Squared, across the entire cross section and all time
r_squared(rt_cross_tune_panel$g, rt_cross_tune_panel$return)
#Tuning Cross Sectional R Squared SKELETON CODE
#Problems, due to randomness, r squared values vary A LOT between different runs
#Individual annualized volatility seems to be more around 25% rather than the required 30%
#Predictive R squared seems to OK around 5%
#We want inidividual r squared for each stock to be 50%
#We want inidividual annualized volatility to be 30%
#We want to cross sectional R squared to be 25%
#We want the predictive R squared to be 5%
#Generate paramaters first
#Tune v_sd for inidividual r square first
#Gu et al had 0.05 for their v sd
v_sd <- 0.05
ep_sd <- 0.05
theta <- matrix(c(0.02, 0.02, 0.02), nrow = 1)
resid <- gu_gen_rt_resid(v_sd, ep_sd)
g <- gu_gen_g(gu_g1)
rt_cross_tune_list <- rep(list(NULL), Time)
for (t in 1:(Time+1)) {
df <- data.frame(resid = resid[[t]], g = g[[t]], time = rep(t, N), stock = c(1:N))
rt_cross_tune_list[[t]] <- df
}
rt_cross_tune_panel <- rt_cross_tune_list[[1]]
for (t in 1:(Time+1)) {
rt_cross_tune_panel <- rbind(rt_cross_tune_panel, rt_cross_tune_list[[t]])
}
#Remove 1st row because returns data only starts from t = 2
rt_cross_tune_panel <- rt_cross_tune_panel %>%
filter(time != 1) %>%
mutate(return = resid + g) %>%
#Generate Squared Series
mutate(return_sq = ((return)^2)) %>%
mutate(resid_sq = resid^2) %>%
mutate(g_sq = (g - mean(return))^2)
summary(rt_cross_tune_panel$resid_sq + rt_cross_tune_panel$g_sq - rt_cross_tune_panel$return_sq)
######################################################################################
#Individual return R squared
rt_id_tune_df <- data.frame(
stock = c(1:N),
rsquare = c(1:N)
)
for (i in 1:N) {
rt_id_tune_panel <- rt_cross_tune_panel %>%
filter(stock == i)
rt_id_tune_df$rsquare[i] <- r_squared(rt_cross_tune_panel$g, rt_cross_tune_panel$return)
}
#Return mean of each individual rsquared
mean(rt_id_tune_df$rsquare)
######################################################################################
#Calculate Annualized Volatility
#Annualized volatility = calculate volatility (via standard deviation) for the monthly returns, then annualize it by multiplying it by sqrt(12) for 12 months in a year
vol_tune_df <- data.frame(
stock = c(1:N),
annual_vol = c(1:N)
)
for (i in 1:N) {
vol_tune_panel <- rt_cross_tune_panel %>%
filter(stock == i)
vol_tune_df$annual_vol[i] <- sd(vol_tune_panel$return) * sqrt(12)
}
#Return the mean annualized volatility
#Want this around 30%
mean(vol_tune_df$annual_vol)
######################################################################################
#Cross Sectional R Squared for a given time period
rt_cross_section <- data.frame(
time = rep(0, Time),
rsquare = rep(0, Time)
)
for (t in 2:(Time+1)) {
rt_cross_section$time <- t
rt_cross_tune_panel_cross_section <- rt_cross_tune_panel %>%
filter(time == t)
rt_cross_section$rsquare[t-1] <- r_squared(rt_cross_tune_panel_cross_section$g, rt_cross_tune_panel_cross_section$return)
}
mean(rt_cross_section$rsquare)
######################################################################################
#Predictive R Squared, across the entire cross section and all time
r_squared(rt_cross_tune_panel$g, rt_cross_tune_panel$return)
#Tuning Cross Sectional R Squared SKELETON CODE
#Problems, due to randomness, r squared values vary A LOT between different runs
#Individual annualized volatility seems to be more around 25% rather than the required 30%
#Predictive R squared seems to OK around 5%
#We want inidividual r squared for each stock to be 50%
#We want inidividual annualized volatility to be 30%
#We want to cross sectional R squared to be 25%
#We want the predictive R squared to be 5%
#Generate paramaters first
#Tune v_sd for inidividual r square first
#Gu et al had 0.05 for their v sd
v_sd <- 0.05
ep_sd <- 0.05
theta <- matrix(c(0.02, 0.02, 0.02), nrow = 1)
resid <- gu_gen_rt_resid(v_sd, ep_sd)
g <- gu_gen_g(gu_g1)
rt_cross_tune_list <- rep(list(NULL), Time)
for (t in 1:(Time+1)) {
df <- data.frame(resid = resid[[t]], g = g[[t]], time = rep(t, N), stock = c(1:N))
rt_cross_tune_list[[t]] <- df
}
rt_cross_tune_panel <- rt_cross_tune_list[[1]]
for (t in 1:(Time+1)) {
rt_cross_tune_panel <- rbind(rt_cross_tune_panel, rt_cross_tune_list[[t]])
}
#Remove 1st row because returns data only starts from t = 2
rt_cross_tune_panel <- rt_cross_tune_panel %>%
filter(time != 1) %>%
mutate(return = resid + g) %>%
#Generate Squared Series
mutate(return_sq = ((return)^2)) %>%
mutate(resid_sq = resid^2) %>%
mutate(g_sq = (g - mean(return))^2)
summary(rt_cross_tune_panel$resid_sq + rt_cross_tune_panel$g_sq - rt_cross_tune_panel$return_sq)
######################################################################################
#Individual return R squared
rt_id_tune_df <- data.frame(
stock = c(1:N),
rsquare = c(1:N)
)
for (i in 1:N) {
rt_id_tune_panel <- rt_cross_tune_panel %>%
filter(stock == i)
rt_id_tune_df$rsquare[i] <- r_squared(rt_cross_tune_panel$g, rt_cross_tune_panel$return)
}
#Return mean of each individual rsquared
mean(rt_id_tune_df$rsquare)
######################################################################################
#Calculate Annualized Volatility
#Annualized volatility = calculate volatility (via standard deviation) for the monthly returns, then annualize it by multiplying it by sqrt(12) for 12 months in a year
vol_tune_df <- data.frame(
stock = c(1:N),
annual_vol = c(1:N)
)
for (i in 1:N) {
vol_tune_panel <- rt_cross_tune_panel %>%
filter(stock == i)
vol_tune_df$annual_vol[i] <- sd(vol_tune_panel$return) * sqrt(12)
}
#Return the mean annualized volatility
#Want this around 30%
mean(vol_tune_df$annual_vol)
######################################################################################
#Cross Sectional R Squared for a given time period
rt_cross_section <- data.frame(
time = rep(0, Time),
rsquare = rep(0, Time)
)
for (t in 2:(Time+1)) {
rt_cross_section$time <- t
rt_cross_tune_panel_cross_section <- rt_cross_tune_panel %>%
filter(time == t)
rt_cross_section$rsquare[t-1] <- r_squared(rt_cross_tune_panel_cross_section$g, rt_cross_tune_panel_cross_section$return)
}
mean(rt_cross_section$rsquare)
######################################################################################
#Predictive R Squared, across the entire cross section and all time
r_squared(rt_cross_tune_panel$g, rt_cross_tune_panel$return)
#Tuning Cross Sectional R Squared SKELETON CODE
#Problems, due to randomness, r squared values vary A LOT between different runs
#Individual annualized volatility seems to be more around 25% rather than the required 30%
#Predictive R squared seems to OK around 5%
#We want inidividual r squared for each stock to be 50%
#We want inidividual annualized volatility to be 30%
#We want to cross sectional R squared to be 25%
#We want the predictive R squared to be 5%
#Generate paramaters first
#Tune v_sd for inidividual r square first
#Gu et al had 0.05 for their v sd
v_sd <- 0.05
ep_sd <- 0.05
theta <- matrix(c(0.02, 0.02, 0.02), nrow = 1)
resid <- gu_gen_rt_resid(v_sd, ep_sd)
g <- gu_gen_g(gu_g1)
rt_cross_tune_list <- rep(list(NULL), Time)
for (t in 1:(Time+1)) {
df <- data.frame(resid = resid[[t]], g = g[[t]], time = rep(t, N), stock = c(1:N))
rt_cross_tune_list[[t]] <- df
}
rt_cross_tune_panel <- rt_cross_tune_list[[1]]
for (t in 1:(Time+1)) {
rt_cross_tune_panel <- rbind(rt_cross_tune_panel, rt_cross_tune_list[[t]])
}
#Remove 1st row because returns data only starts from t = 2
rt_cross_tune_panel <- rt_cross_tune_panel %>%
filter(time != 1) %>%
mutate(return = resid + g) %>%
#Generate Squared Series
mutate(return_sq = ((return)^2)) %>%
mutate(resid_sq = resid^2) %>%
mutate(g_sq = (g - mean(return))^2)
summary(rt_cross_tune_panel$resid_sq + rt_cross_tune_panel$g_sq - rt_cross_tune_panel$return_sq)
######################################################################################
#Individual return R squared
rt_id_tune_df <- data.frame(
stock = c(1:N),
rsquare = c(1:N)
)
for (i in 1:N) {
rt_id_tune_panel <- rt_cross_tune_panel %>%
filter(stock == i)
rt_id_tune_df$rsquare[i] <- r_squared(rt_cross_tune_panel$g, rt_cross_tune_panel$return)
}
#Return mean of each individual rsquared
mean(rt_id_tune_df$rsquare)
######################################################################################
#Calculate Annualized Volatility
#Annualized volatility = calculate volatility (via standard deviation) for the monthly returns, then annualize it by multiplying it by sqrt(12) for 12 months in a year
vol_tune_df <- data.frame(
stock = c(1:N),
annual_vol = c(1:N)
)
for (i in 1:N) {
vol_tune_panel <- rt_cross_tune_panel %>%
filter(stock == i)
vol_tune_df$annual_vol[i] <- sd(vol_tune_panel$return) * sqrt(12)
}
#Return the mean annualized volatility
#Want this around 30%
mean(vol_tune_df$annual_vol)
######################################################################################
#Cross Sectional R Squared for a given time period
rt_cross_section <- data.frame(
time = rep(0, Time),
rsquare = rep(0, Time)
)
for (t in 2:(Time+1)) {
rt_cross_section$time <- t
rt_cross_tune_panel_cross_section <- rt_cross_tune_panel %>%
filter(time == t)
rt_cross_section$rsquare[t-1] <- r_squared(rt_cross_tune_panel_cross_section$g, rt_cross_tune_panel_cross_section$return)
}
mean(rt_cross_section$rsquare)
######################################################################################
#Predictive R Squared, across the entire cross section and all time
r_squared(rt_cross_tune_panel$g, rt_cross_tune_panel$return)
#Tuning Cross Sectional R Squared SKELETON CODE
#Problems, due to randomness, r squared values vary A LOT between different runs
#Individual annualized volatility seems to be more around 25% rather than the required 30%
#Predictive R squared seems to OK around 5%
#We want inidividual r squared for each stock to be 50%
#We want inidividual annualized volatility to be 30%
#We want to cross sectional R squared to be 25%
#We want the predictive R squared to be 5%
#Generate paramaters first
#Tune v_sd for inidividual r square first
#Gu et al had 0.05 for their v sd
v_sd <- 0.05
ep_sd <- 0.05
theta <- matrix(c(0.02, 0.02, 0.02), nrow = 1)
resid <- gu_gen_rt_resid(v_sd, ep_sd)
g <- gu_gen_g(gu_g1)
rt_cross_tune_list <- rep(list(NULL), Time)
for (t in 1:(Time+1)) {
df <- data.frame(resid = resid[[t]], g = g[[t]], time = rep(t, N), stock = c(1:N))
rt_cross_tune_list[[t]] <- df
}
rt_cross_tune_panel <- rt_cross_tune_list[[1]]
for (t in 1:(Time+1)) {
rt_cross_tune_panel <- rbind(rt_cross_tune_panel, rt_cross_tune_list[[t]])
}
#Remove 1st row because returns data only starts from t = 2
rt_cross_tune_panel <- rt_cross_tune_panel %>%
filter(time != 1) %>%
mutate(return = resid + g) %>%
#Generate Squared Series
mutate(return_sq = ((return)^2)) %>%
mutate(resid_sq = resid^2) %>%
mutate(g_sq = (g - mean(return))^2)
summary(rt_cross_tune_panel$resid_sq + rt_cross_tune_panel$g_sq - rt_cross_tune_panel$return_sq)
######################################################################################
#Individual return R squared
rt_id_tune_df <- data.frame(
stock = c(1:N),
rsquare = c(1:N)
)
for (i in 1:N) {
rt_id_tune_panel <- rt_cross_tune_panel %>%
filter(stock == i)
rt_id_tune_df$rsquare[i] <- r_squared(rt_cross_tune_panel$g, rt_cross_tune_panel$return)
}
#Return mean of each individual rsquared
mean(rt_id_tune_df$rsquare)
######################################################################################
#Calculate Annualized Volatility
#Annualized volatility = calculate volatility (via standard deviation) for the monthly returns, then annualize it by multiplying it by sqrt(12) for 12 months in a year
vol_tune_df <- data.frame(
stock = c(1:N),
annual_vol = c(1:N)
)
for (i in 1:N) {
vol_tune_panel <- rt_cross_tune_panel %>%
filter(stock == i)
vol_tune_df$annual_vol[i] <- sd(vol_tune_panel$return) * sqrt(12)
}
#Return the mean annualized volatility
#Want this around 30%
mean(vol_tune_df$annual_vol)
######################################################################################
#Cross Sectional R Squared for a given time period
rt_cross_section <- data.frame(
time = rep(0, Time),
rsquare = rep(0, Time)
)
for (t in 2:(Time+1)) {
rt_cross_section$time <- t
rt_cross_tune_panel_cross_section <- rt_cross_tune_panel %>%
filter(time == t)
rt_cross_section$rsquare[t-1] <- r_squared(rt_cross_tune_panel_cross_section$g, rt_cross_tune_panel_cross_section$return)
}
mean(rt_cross_section$rsquare)
######################################################################################
#Predictive R Squared, across the entire cross section and all time
r_squared(rt_cross_tune_panel$g, rt_cross_tune_panel$return)
#Tuning Cross Sectional R Squared SKELETON CODE
#Problems, due to randomness, r squared values vary A LOT between different runs
#Individual annualized volatility seems to be more around 25% rather than the required 30%
#Predictive R squared seems to OK around 5%
#We want inidividual r squared for each stock to be 50%
#We want inidividual annualized volatility to be 30%
#We want to cross sectional R squared to be 25%
#We want the predictive R squared to be 5%
#Generate paramaters first
#Tune v_sd for inidividual r square first
#Gu et al had 0.05 for their v sd
v_sd <- 0.05
ep_sd <- 0.05
theta <- matrix(c(0.02, 0.02, 0.02), nrow = 1)
resid <- gu_gen_rt_resid(v_sd, ep_sd)
g <- gu_gen_g(gu_g1)
rt_cross_tune_list <- rep(list(NULL), Time)
for (t in 1:(Time+1)) {
df <- data.frame(resid = resid[[t]], g = g[[t]], time = rep(t, N), stock = c(1:N))
rt_cross_tune_list[[t]] <- df
}
rt_cross_tune_panel <- rt_cross_tune_list[[1]]
for (t in 1:(Time+1)) {
rt_cross_tune_panel <- rbind(rt_cross_tune_panel, rt_cross_tune_list[[t]])
}
#Remove 1st row because returns data only starts from t = 2
rt_cross_tune_panel <- rt_cross_tune_panel %>%
filter(time != 1) %>%
mutate(return = resid + g) %>%
#Generate Squared Series
mutate(return_sq = ((return)^2)) %>%
mutate(resid_sq = resid^2) %>%
mutate(g_sq = (g - mean(return))^2)
summary(rt_cross_tune_panel$resid_sq + rt_cross_tune_panel$g_sq - rt_cross_tune_panel$return_sq)
######################################################################################
#Individual return R squared
rt_id_tune_df <- data.frame(
stock = c(1:N),
rsquare = c(1:N)
)
for (i in 1:N) {
rt_id_tune_panel <- rt_cross_tune_panel %>%
filter(stock == i)
rt_id_tune_df$rsquare[i] <- r_squared(rt_cross_tune_panel$g, rt_cross_tune_panel$return)
}
#Return mean of each individual rsquared
mean(rt_id_tune_df$rsquare)
######################################################################################
#Calculate Annualized Volatility
#Annualized volatility = calculate volatility (via standard deviation) for the monthly returns, then annualize it by multiplying it by sqrt(12) for 12 months in a year
vol_tune_df <- data.frame(
stock = c(1:N),
annual_vol = c(1:N)
)
for (i in 1:N) {
vol_tune_panel <- rt_cross_tune_panel %>%
filter(stock == i)
vol_tune_df$annual_vol[i] <- sd(vol_tune_panel$return) * sqrt(12)
}
#Return the mean annualized volatility
#Want this around 30%
mean(vol_tune_df$annual_vol)
######################################################################################
#Cross Sectional R Squared for a given time period
rt_cross_section <- data.frame(
time = rep(0, Time),
rsquare = rep(0, Time)
)
for (t in 2:(Time+1)) {
rt_cross_section$time <- t
rt_cross_tune_panel_cross_section <- rt_cross_tune_panel %>%
filter(time == t)
rt_cross_section$rsquare[t-1] <- r_squared(rt_cross_tune_panel_cross_section$g, rt_cross_tune_panel_cross_section$return)
}
mean(rt_cross_section$rsquare)
######################################################################################
#Predictive R Squared, across the entire cross section and all time
r_squared(rt_cross_tune_panel$g, rt_cross_tune_panel$return)
#Tuning Cross Sectional R Squared SKELETON CODE
#Problems, due to randomness, r squared values vary A LOT between different runs
#Individual annualized volatility seems to be more around 25% rather than the required 30%
#Cross sectional r squared seems to be around 5%, too low
#Predictive R squared seems to OK around 5%
#We want inidividual r squared for each stock to be 50%
#We want inidividual annualized volatility to be 30%
#We want to cross sectional R squared to be 25%
#We want the predictive R squared to be 5%
#Generate paramaters first
#Tune v_sd for inidividual r square first
#Gu et al had 0.05 for their v sd
v_sd <- 0.05
ep_sd <- 0.05
theta <- matrix(c(0.02, 0.02, 0.02), nrow = 1)
resid <- gu_gen_rt_resid(v_sd, ep_sd)
g <- gu_gen_g(gu_g1)
rt_cross_tune_list <- rep(list(NULL), Time)
for (t in 1:(Time+1)) {
df <- data.frame(resid = resid[[t]], g = g[[t]], time = rep(t, N), stock = c(1:N))
rt_cross_tune_list[[t]] <- df
}
rt_cross_tune_panel <- rt_cross_tune_list[[1]]
for (t in 1:(Time+1)) {
rt_cross_tune_panel <- rbind(rt_cross_tune_panel, rt_cross_tune_list[[t]])
}
#Remove 1st row because returns data only starts from t = 2
rt_cross_tune_panel <- rt_cross_tune_panel %>%
filter(time != 1) %>%
mutate(return = resid + g) %>%
#Generate Squared Series
mutate(return_sq = ((return)^2)) %>%
mutate(resid_sq = resid^2) %>%
mutate(g_sq = (g - mean(return))^2)
summary(rt_cross_tune_panel$resid_sq + rt_cross_tune_panel$g_sq - rt_cross_tune_panel$return_sq)
######################################################################################
#Individual return R squared
rt_id_tune_df <- data.frame(
stock = c(1:N),
rsquare = c(1:N)
)
for (i in 1:N) {
rt_id_tune_panel <- rt_cross_tune_panel %>%
filter(stock == i)
rt_id_tune_df$rsquare[i] <- r_squared(rt_cross_tune_panel$g, rt_cross_tune_panel$return)
}
#Return mean of each individual rsquared
mean(rt_id_tune_df$rsquare)
######################################################################################
#Calculate Annualized Volatility
#Annualized volatility = calculate volatility (via standard deviation) for the monthly returns, then annualize it by multiplying it by sqrt(12) for 12 months in a year
vol_tune_df <- data.frame(
stock = c(1:N),
annual_vol = c(1:N)
)
for (i in 1:N) {
vol_tune_panel <- rt_cross_tune_panel %>%
filter(stock == i)
vol_tune_df$annual_vol[i] <- sd(vol_tune_panel$return) * sqrt(12)
}
#Return the mean annualized volatility
#Want this around 30%
mean(vol_tune_df$annual_vol)
######################################################################################
#Cross Sectional R Squared for a given time period
rt_cross_section <- data.frame(
time = rep(0, Time),
rsquare = rep(0, Time)
)
for (t in 2:(Time+1)) {
rt_cross_section$time <- t
rt_cross_tune_panel_cross_section <- rt_cross_tune_panel %>%
filter(time == t)
rt_cross_section$rsquare[t-1] <- r_squared(rt_cross_tune_panel_cross_section$g, rt_cross_tune_panel_cross_section$return)
}
mean(rt_cross_section$rsquare)
######################################################################################
#Predictive R Squared, across the entire cross section and all time
r_squared(rt_cross_tune_panel$g, rt_cross_tune_panel$return)
