panel_tune_stats <- function(return_panel, true_factor_panel) {
#Initialize
tune_stats <- data.frame(time_series_fitted.rsquare = 0, annual_vol = 0, cross_section_rsquare = 0)
########
## Time Series + Annual Vol
########
#Empty Matrices to be used
Rsquared <- matrix(0, N, 1)
SSR <- matrix(0, N, 1)
SST <- matrix(0, N, 1)
Fits <- matrix(0, Time, N)
#This stores all the BETAS, NOT the constant
Coeff_Betas <- matrix(0, N, ncol(true_factor_panel))
Xs_bar <- matrix(0, N, ncol(true_factor_panel))
R_bar <- matrix(0, N, 1)
Resids <- matrix(0, Time, N)
annual_vol <- matrix(0, N, 1)
#Done for the g1 case for now
#First run individual time series regressions
for (i in 1:N) {
#True Returns
Rs <- return_panel[i, , ]
R_bar[i, 1] <- mean(Rs)
#True Factor Set
Xs <- t(true_factor_panel[i, , ])
#Not too sure what this is doing, not used anywhere else
Xs_bar[i, ] <- colMeans(Xs)
df <- data.frame(Rs, Xs)
fit <- lm(Rs ~., df)
Fits[, i] <- fit$fitted.values
#Save all the betas except for the constant, slightly more clever way that handles different number of true factors
Coeff_Betas[i, ] <- as.numeric(fit$coefficients[-1])
Resids[, i] <- fit$residuals
SSR[i, 1] <- sum(Resids[, i]^2)
SST[i, 1] <- sum((Rs-mean(Rs))^2)
Rsquared[i, 1] <- summary(fit)$r.squared
#annualized volatility
annual_vol[i] <- sd(Rs) * sqrt(12)
}
tune_stats$time_series_fitted.rsquare <- mean(Rsquared)
tune_stats$annual_vol <- mean(annual_vol)
# Not too sure what is going on here
# val <- g1(C,x,theta)
# true_res <- rowSums((rt - val)^2)
# true_sst <- rowSums((rt - rowMeans(rt))^2)
# true_rRsquared <- 1 - (sum(true_res)/sum(true_sst))
# fitted_Rsquared <- 1 - (sum(SSR)/sum(SST))
# Cross Sectional Correlation
R_bar <- rowMeans(return_panel)
df_new <- data.frame(R_bar, Coeff_Betas)
cross_fit <- lm(R_bar ~ Coeff_Betas, df_new)
tune_stats$cross_section_rsquare <- summary(cross_fit)$r.squared
return(tune_stats)
}
#Works, hooray
panel_tune_stats(rt_panel_g1_A1, g1_factor_panel)
##############################################################################
##Function to build predictor set for the entire panel
##############################################################################
#Kronecker product
# Calculated with z_it = (1, xt)' \otimes c_it
# xt should be P_x x 1
# c_it should be P_c x 1
# z_it should be a P_c*(P_x + 1) x 1 vector of features
#
gen_predictor_z <- function(C, x){
xt_set <- rbind(1, x)
dimnames(xt_set)[[1]][1] <- "constant"
stock_dim <- paste0("stock_", c(1:N))
c_dim <- dimnames(kronecker(t(xt_set[, 1]), t(C[1, , 1]), make.dimnames = TRUE))[[2]]
time_dim <- paste0("time_", c(1:(Time)))
z_panel <- array(0, dim = c(N, (nrow(xt)+1) * P_c, Time), dimnames = list(stock_dim, c_dim, time_dim))
for (i in 1:N) {
for (t in 1:Time) {
z_panel[i, , t] <- kronecker(t(xt_set[, t]), t(C[i, , t]), make.dimnames = TRUE)
}
}
return(z_panel)
}
gen_predictor_z(C, xt)
z_panel_g1_A1 <- gen_predictor_z(C, xt)
#Yes bitch it's working
# Bind Returns and Predictor Sets Together into one 2D dataframe, ready to be used for training models
bind_rt_predictor <- function(rt_panel, z_panel) {
df <- cbind(data.frame(rt_panel_g1_A1[, , 1]), time = 2, stock = paste0("stock_", c(1:N)), data.frame(z_panel_g1_A1[, , 1]))
colnames(df)[1] <- "rt"
row.names(df) <- NULL
for (t in 2:Time) {
df_new <- cbind(data.frame(rt_panel_g1_A1[, , t]), time = 1+t, stock = paste0("stock_", c(1:N)), data.frame(z_panel_g1_A1[, , t]))
colnames(df_new)[1] <- "rt"
row.names(df_new) <- NULL
df <- rbind(df, df_new)
}
return(df)
}
#test
panel_g1_A1 <- bind_rt_predictor(rt_panel_g1_A1, z_panel_g1_A1)
#With that... DONE WITH THIS PART OF THE PROJECT
##########################
A1 <- matrix(c(
0.95, 0, 0,
0, 0.95, 0,
0, 0, 0.95),
nrow = 3, ncol = 3
)
A2 <- matrix(c(
1, 0, 0.25,
0, 0.95, 0,
0.25, 0, 0.95),
nrow = 3, ncol = 3
)
A3 <- matrix(c(
0.99, 0.2, 0.1,
0.2, 0.90, -0.3,
0.1, -0.3, -0.99),
nrow = 3, ncol = 3
)
##########################
# Simulate a specification 100 times
sim_tune <- function(sim_N, cross_corr, A_matrix, xt_multi, g_function, theta,
#Error Parameters
error_sv, error_omega, error_gamma, error_w, error_v_sd) {
sim_tune_stats <- data.frame(time_series_fitted.rsquare = rep(0, sim_N), annual_vol = rep(0, sim_N), cross_section_rsquare = rep(0, sim_N))
for (s in 1:sim_N) {
C_bar <- gen_C_bar()
C_hat <- gen_C_hat(C_bar)
if (cross_corr == 0) {
C <- gen_C(C_bar)
}
else {
C <- gen_C(C_hat)
}
if (xt_multi == 1) {
xt <- gen_xt(A_matrix)
}
else {
xt <- gen_xt_univariate()
}
#Generate the true underlying factors first
g_factor_panel <- gen_g_factor_panel(g_function, C, xt)
#Then pass them through to multiply them by theta to get g()
g_panel <- gen_g_panel(g_factor_panel, theta)
#Generate the errors
error <- gen_error(sv = error_sv, 0.05, omega = error_omega, gamma = error_gamma, w = error_w, C, v_sd = error_v_sd)
rt_panel <- g_panel + error
sim_tune_stats[s,] <- panel_tune_stats(rt_panel, g_factor_panel)
}
summary(sim_tune_stats)
}
# Actual Generation of the datasets
#Overall Dimensionality
N <- 20
P_c <- 10
Time <- 18
sim_tune <- function(sim_N, cross_corr, A_matrix, xt_multi, g_function, theta,
#Error Parameters
error_sv, error_omega, error_gamma, error_w, error_v_sd) {
#Initialize
dataset <- list(sim_tune_stats = data.frame(time_series_fitted.rsquare = 0,
annual_vol = 0,
cross_section_rsquare = 0),
data = 0
)
dataset2 <- list(sim_tune_stats = data.frame(time_series_fitted.rsquare = 0,
annual_vol = 0,
cross_section_rsquare = 0),
data = 0
)
datasets <- list(dataset, dataset2)
for (s in 1:sim_N) {
C_bar <- gen_C_bar()
C_hat <- gen_C_hat(C_bar)
if (cross_corr == 0) {
C <- gen_C(C_bar)
}
else {
C <- gen_C(C_hat)
}
if (xt_multi == 1) {
xt <- gen_xt(A_matrix)
}
else {
xt <- gen_xt_univariate()
}
#Generate the true underlying factors first
g_factor_panel <- gen_g_factor_panel(g_function, C, xt)
#Then pass them through to multiply them by theta to get g()
g_panel <- gen_g_panel(g_factor_panel, theta)
#Generate the errors
error <- gen_error(sv = error_sv, 0.05, omega = error_omega, gamma = error_gamma, w = error_w, C, v_sd = error_v_sd)
rt_panel <- g_panel + error
sim_tune_stats[s,] <- panel_tune_stats(rt_panel, g_factor_panel)
}
}
View(panel_g1_A1)
?createTimeSlices
start <- 2
end <- 181
initialWindow <- 108
horizon <- 12
test <- 36
knitr::opts_chunk$set(echo = TRUE)
################
##Load Libraries
################
library(glmnet)
library(tidyverse)
library(keras)
library(ggplot2)
library(caret)
library(forecast)
library(rlist)
library(plm)
library(Metrics)
library(ranger)
set.seed(27935248)
total <- c(start:end)
set_num <- (total - test - initialWindow) / horizon
offset <- start - 1
for (t in 1:set_num) {
train <- c(start:(initialWindow + (t-1) * horizon + offset))
validation <- c((initialWindow + (t-1) * horizon + offset + 1):(initialWindow + (t) * horizon + offset + 1))
test <- c((initialWindow + (t) * horizon + offset + 1 + 1):end)
}
total <- c(start:end)
set_num <- (end - start - test - initialWindow) / horizon
offset <- start - 1
for (t in 1:set_num) {
train <- c(start:(initialWindow + (t-1) * horizon + offset))
validation <- c((initialWindow + (t-1) * horizon + offset + 1):(initialWindow + (t) * horizon + offset + 1))
test <- c((initialWindow + (t) * horizon + offset + 1 + 1):end)
}
train
total <- c(start:end)
set_num <- (end - start - test - initialWindow) / horizon
offset <- start - 1
test <- 36
total <- c(start:end)
set_num <- (end - start - test - initialWindow) / horizon
test_size <- 36
t
total <- c(start:end)
set_num <- (end - start - test_size - initialWindow) / horizon
offset <- start - 1
for (t in 1:set_num) {
train <- c(start:(initialWindow + (t-1) * horizon + offset))
validation <- c((initialWindow + (t-1) * horizon + offset + 1):(initialWindow + (t) * horizon + offset + 1))
test <- c((initialWindow + (t) * horizon + offset + 1 + 1):end)
}
set_num <- (end - start - test_size - initialWindow) / horizon
offset <- start - 1
set_num <- (end - start + offset - test_size - initialWindow) / horizon
for (t in 1:set_num) {
train <- c(start:(initialWindow + (t-1) * horizon + offset))
validation <- c((initialWindow + (t-1) * horizon + offset + 1):(initialWindow + (t) * horizon + offset + 1))
test <- c((initialWindow + (t) * horizon + offset + 1 + 1):end)
}
train
validation
test
length(validation)
length(train)
length(test)
total <- c(start:end)
offset <- start - 1
set_num <- (end - start + offset - test_size - initialWindow) / horizon
for (t in 1:set_num) {
train <- c(start:(initialWindow + (t-1) * horizon + offset))
validation <- c((initialWindow + (t-1) * horizon + offset + 1):(initialWindow + (t) * horizon + offset))
test <- c((initialWindow + (t) * horizon + offset + 1):end)
}
length(test)
length(validation)
time_slice <- list(train = 0, validation = 0, test = 0)
View(time_slice)
time_slice$train
time_slices <- rep(time_slice, set_num)
time_slices <- list(time_slice, time_slice, time_slice)
time_slices <- list(1 = time_slice, 2 = time_slice, 3 = time_slice)
time_slice <- list(train = 0, validation = 0, test = 0)
for (t in 1:set_num) {
time_slice$train <- c(start:(initialWindow + (t-1) * horizon + offset))
time_slice$validation <- c((initialWindow + (t-1) * horizon + offset + 1):(initialWindow + (t) * horizon + offset))
time_slice$test <- c((initialWindow + (t) * horizon + offset + 1):end)
}
View(time_slices)
time_slices <- rep(time_slice, 3)
time_slices <- list(rep(time_slice, 3))
rep(time_slice, 3)
time_slices <- rep(list(time_slice), 3)
offset <- start - 1
set_num <- (end - start + offset - test_size - initialWindow) / horizon
time_slice <- list(train = 0, validation = 0, test = 0)
time_slices <- rep(list(time_slice), 3)
for (t in 1:set_num) {
time_slice$train <- c(start:(initialWindow + (t-1) * horizon + offset))
time_slice$validation <- c((initialWindow + (t-1) * horizon + offset + 1):(initialWindow + (t) * horizon + offset))
time_slice$test <- c((initialWindow + (t) * horizon + offset + 1):end)
time_slices[[1]] <- time_slice
}
for (t in 1:set_num) {
time_slice$train <- c(start:(initialWindow + (t-1) * horizon + offset))
time_slice$validation <- c((initialWindow + (t-1) * horizon + offset + 1):(initialWindow + (t) * horizon + offset))
time_slice$test <- c((initialWindow + (t) * horizon + offset + 1):end)
time_slices[[t]] <- time_slice
}
View(panel_g1_A1)
time_slices
timeSlices
#Create custom time slices
timeSlices <- customeTimeSlices(start = 2, end = 181, initialWindow = 108, horizon = 12, test_size = 36)
customTimeSlices <- function(start, end, initialWindow, horizon, test_size) {
total <- c(start:end)
offset <- start - 1
set_num <- (end - start + offset - test_size - initialWindow) / horizon
time_slice <- list(train = 0, validation = 0, test = 0)
time_slices <- rep(list(time_slice), 3)
for (t in 1:set_num) {
time_slice$train <- c(start:(initialWindow + (t-1) * horizon + offset))
time_slice$validation <- c((initialWindow + (t-1) * horizon + offset + 1):(initialWindow + (t) * horizon + offset))
time_slice$test <- c((initialWindow + (t) * horizon + offset + 1):end)
time_slices[[t]] <- time_slice
}
}
#Create custom time slices
timeSlices <- customTimeSlices(start = 2, end = 181, initialWindow = 108, horizon = 12, test_size = 36)
timeSlices
customTimeSlices <- function(start, end, initialWindow, horizon, test_size) {
total <- c(start:end)
offset <- start - 1
set_num <- (end - start + offset - test_size - initialWindow) / horizon
time_slice <- list(train = 0, validation = 0, test = 0)
time_slices <- rep(list(time_slice), 3)
for (t in 1:set_num) {
time_slice$train <- c(start:(initialWindow + (t-1) * horizon + offset))
time_slice$validation <- c((initialWindow + (t-1) * horizon + offset + 1):(initialWindow + (t) * horizon + offset))
time_slice$test <- c((initialWindow + (t) * horizon + offset + 1):end)
time_slices[[t]] <- time_slice
}
return(time_slices)
}
#Create custom time slices
timeSlices <- customTimeSlices(start = 2, end = 181, initialWindow = 108, horizon = 12, test_size = 36)
timeSlices
timeSlices
timeSlices[[1]]
pooled_panel <- panel_g1_A1
#Expand formula manually this way because PLM is dumb and gets confused by y ~ .
plm_formula <- function(panel){
colnames <- colnames(panel)
#Remove the first 3 colNames, as these correspond to the return, time and stock id
colnames <- colnames[-c(1:3)]
f <- as.formula(c("return ~ ", paste(colnames, collapse = "+")))
return(f)
}
f <- plm_formula(pooled_panel)
POLS_forecasts <- rep(list(0), 3)
POLS_models <- rep(list(0), 3)
train <- pooled_panel %>%
filter(time %in% timeSlices[[1]]$train)
View(train)
for (set in 1:3) {
#Load Training, validation and test sets
train <- pooled_panel %>%
filter(time %in% timeSlices[[set]]$train)
validation <- pooled_panel %>%
filter(time %in% timeSlices[[set]]$validation)
test<- pooled_panel %>%
filter(time %in% timeSlices[[set]]$test)
#Train Model on training set
pols <- plm(f, data = train, model = "pooling", index = c("time", "stock"))
POLS_models[[set]] <- pols
#No Tuning Needed
#Statistics
#Training Set Statistics
POLS_stats$train_MAE[set] <- mae(train$return, predict(pols))
POLS_stats$train_MSE[set] <- mse(train$return, predict(pols))
POLS_stats$train_RMSE[set] <- rmse(train$return, predict(pols))
error <- (train$return - predict(pols))
SSR <- t(error) %*% (error)
SST <- t(train$return - mean(train$return)) %*% (train$return - mean(train$return))
POLS_stats$train_R2[set] <- (1 - SSR/SST)
#Validation Set Statistics
POLS_stats$valid_MAE[set] <- mae(validation$return, predict(pols, newdata = validation))
POLS_stats$valid_MSE[set] <- mse(validation$return, predict(pols, newdata = validation))
POLS_stats$valid_RMSE[set] <- rmse(validation$return, predict(pols, newdata = validation))
error <- (validation$return - predict(pols, newdata = validation))
SSR <- t(error) %*% (error)
SST <- t(validation$return - mean(validation$return)) %*% (validation$return - mean(validation$return))
POLS_stats$valid_R2[set] <- (1 - SSR/SST)
#Test Set Statistics
POLS_stats$test_MAE[set] <- mae(test$return, predict(pols, newdata = test))
POLS_stats$test_MSE[set] <- mse(test$return, predict(pols, newdata = test))
POLS_stats$test_RMSE[set] <- rmse(test$return, predict(pols, newdata = test))
error <- (test$return - predict(pols, newdata = test))
SSR <- t(error) %*% (error)
SST <- t(test$return - mean(test$return)) %*% (test$return - mean(test$return))
POLS_stats$test_R2[set] <- (1 - SSR/SST)
#Forecasts
POLS_forecasts[[set]]$forecast <- predict(pols, newdata = test)
POLS_forecasts[[set]]$forecast_error <- test$return - predict(pols, newdata = test)
}
pols <- plm(f, data = train, model = "pooling", index = c("time", "stock"))
#Expand formula manually this way because PLM is dumb and gets confused by y ~ .
plm_formula <- function(panel){
colnames <- colnames(panel)
#Remove the first 3 colNames, as these correspond to the return, time and stock id
colnames <- colnames[-c(1:3)]
f <- as.formula(c(colnames(panel)[1], paste(colnames, collapse = "+")))
return(f)
}
f <- plm_formula(pooled_panel)
#Expand formula manually this way because PLM is dumb and gets confused by y ~ .
plm_formula <- function(panel){
colnames <- colnames(panel)
#Remove the first 3 colNames, as these correspond to the return, time and stock id
colnames <- colnames[-c(1:3)]
f <- as.formula(c(paste(colnames(panel)[1]), paste(colnames, collapse = "+")))
return(f)
}
f <- plm_formula(pooled_panel)
colnames(panel)[1]
colnames(panel)
colnames(pooled_panel)[1]
#Expand formula manually this way because PLM is dumb and gets confused by y ~ .
plm_formula <- function(panel){
colnames <- colnames(panel)
#Remove the first 3 colNames, as these correspond to the return, time and stock id
colnames <- colnames[-c(1:3)]
f <- as.formula(c("rt", paste(colnames, collapse = "+")))
return(f)
}
f <- plm_formula(pooled_panel)
#Expand formula manually this way because PLM is dumb and gets confused by y ~ .
plm_formula <- function(panel){
panel_colnames <- colnames(panel)
#Remove the first 3 colNames, as these correspond to the return, time and stock id
colnames <- panel_colnames[-c(1:3)]
f <- as.formula(c("rt", paste(colnames, collapse = "+")))
return(f)
}
f <- plm_formula(pooled_panel)
pnale <- pooled_panel
panel <- pooled_panel
panel_colnames <- colnames(panel)
#Remove the first 3 colNames, as these correspond to the return, time and stock id
colnames <- panel_colnames[-c(1:3)]
#Remove the first 3 colNames, as these correspond to the return, time and stock id
panel_colnames <- panel_colnames[-c(1:3)]
f <- as.formula(c("rt", paste(panel_colnames, collapse = "+")))
#Expand formula manually this way because PLM is dumb and gets confused by y ~ .
plm_formula <- function(panel){
panel_colnames <- colnames(panel)
#Remove the first 3 colNames, as these correspond to the return, time and stock id
panel_colnames <- panel_colnames[-c(1:3)]
f <- as.formula(c("rt", paste(panel_colnames, collapse = "+")))
return(f)
}
f <- plm_formula(pooled_panel)
paste(panel_colnames, collapse = "+")
c("rt", paste(panel_colnames, collapse = "+"))
#Expand formula manually this way because PLM is dumb and gets confused by y ~ .
plm_formula <- function(panel){
#Remove the first 3 colNames, as these correspond to the return, time and stock id
panel_colnames <- colnames(panel)[-c(1:3)]
f <- as.formula(c("rt", paste(panel_colnames, collapse = "+")))
return(f)
}
f <- plm_formula(pooled_panel)
colnames(panel)[-c(1:3)]
f <- plm_formula(pooled_panel)
plm_formula(pooled_panel)
install.packages("devtools", lib="C:/Program Files/R/R-3.5.0/library")
knitr::opts_chunk$set(echo = TRUE)
################
##Load Libraries
################
library(glmnet)
library(tidyverse)
library(keras)
library(ggplot2)
library(caret)
library(forecast)
library(rlist)
library(plm)
library(Metrics)
library(ranger)
library(glmnetUtils)
install.packages("glmnetUtils", lib="C:/Program Files/R/R-3.5.0/library")
knitr::opts_chunk$set(echo = TRUE)
################
##Load Libraries
################
library(glmnet)
library(tidyverse)
library(keras)
library(ggplot2)
library(caret)
library(forecast)
library(rlist)
library(plm)
library(Metrics)
library(ranger)
library(glmnetUtils)
#forestr
devtools::install_github("andeek/forestr")
devtools::install_github("andeek/rpart")
devtools::install_github("andeek/forestr")
devtools::install_github("andeek/forestr")
devtools::install_github("andeek/forestr")
Sys.getenv("R_LIBS_USER")
devtools::install_github("andeek/forestr")
