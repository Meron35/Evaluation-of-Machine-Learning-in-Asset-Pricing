Coeff_Betas[i,]<-as.numeric(fit$coefficients[2:4])
Resids[,i]<- fit$residuals
SSR[i,1]<- sum(Resids[,i]^2)
SST[i,1]<- sum((Rs-mean(Rs))^2)
Rsquared[i,1]<-summary(fit)$r.squared
}
mean(Rsquared)
val<-g1(C,x,theta)
true_res<- rowSums( (rt - val)^2)
true_sst<- rowSums((rt-rowMeans(rt))^2)
true_rRsquared <- 1-(sum(true_res)/sum(true_sst))
fitted_Rsquared<- 1-(sum(SSR)/sum(SST))
##########################################
# Cross-sectional R-squared
##########################################
R_bar <- rowMeans(rt)
df_new <- data.frame(R_bar,Coeff_Betas)
cross_fit <- lm(R_bar~ Coeff_Betas, df_new)
summary(cross_fit)
?array
array(1:3, c(2,4)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(echo = TRUE)
################
##Load Libraries
################
library(glmnet)
library(tidyverse)
library(keras)
library(ggplot2)
library(caret)
library(forecast)
library(rlist)
library(plm)
library(Metrics)
library(ranger)
set.seed(27935248)
#Change everything so that it is in terms of arrays instead of lists
#Lists were confusing and became hard to work with, also consistent with David
temp <- matrix(
data = 0, nrow = N, ncol = P_c
)
C_bar <- array(
temp, c(N, P_c, (Time+1))
)
C_bar[1, 1]
C_bar[1, 1,]
C_bar[, , 1]
C_bar[, , ,]
?map
?array
C_bar <- array(
data = 0, dim = c(N, P_c, (Time+1))
)
?rep
rho <- rep(0.5, P_c)
gen_C_bar <- function(){
#Initialize am empty array with i, j, t indexing
C_bar <- array(
data = 0, dim = c(N, P_c, (Time+1))
)
#Generate rho vector to be constant across time and stocks
#Original rho vector in draft proposal
#rho <- runif(P_c, 1/2, 1)
#Lower rho values here will give higher time series correlation, and lower cross sectional r squared
for (t in 1:(Time+1)) {
for (j in 1:P_c) {
C_bar[, j, t+1] <- C_bar[, j, t] * rho[j] + rnorm(N, 0, 1)
}
}
##Delete first period full of zeroes
C_bar[, , 1] <- NULL
return(C_bar)
}
C_bar <- gen_C_bar()
gen_C_bar <- function(){
#Initialize am empty array with i, j, t indexing
C_bar <- array(
data = 0, dim = c(N, P_c, (Time+2))
)
#Generate rho vector to be constant across time and stocks
#Original rho vector in draft proposal
#rho <- runif(P_c, 1/2, 1)
#Lower rho values here will give higher time series correlation, and lower cross sectional r squared
for (t in 1:(Time+1)) {
for (j in 1:P_c) {
C_bar[, j, t+1] <- C_bar[, j, t] * rho[j] + rnorm(N, 0, 1)
}
}
##Delete first period full of zeroes
C_bar[, , 1] <- NULL
return(C_bar)
}
C_bar <- gen_C_bar()
###################
##characteristics C_bar
###################
#######
##Function to Generate C_bar
#######
gen_C_bar <- function(){
#Initialize am empty array with i, j, t indexing
C_bar <- array(
data = 0, dim = c(N, P_c, (Time+2))
)
#Generate rho vector to be constant across time and stocks
#Original rho vector in draft proposal
#rho <- runif(P_c, 1/2, 1)
#Lower rho values here will give higher time series correlation, and lower cross sectional r squared
for (t in 1:(Time+1)) {
for (j in 1:P_c) {
C_bar[, j, t+1] <- C_bar[, j, t] * rho[j] + rnorm(N, 0, 1)
}
}
##Delete first period full of zeroes
C_bar <- C_bar[, , -1]
return(C_bar)
}
C_bar <- gen_C_bar()
#######################################
##Generate correlation matrix
#######################################
gen_W <- function(){
#Generate Lambda Matrix first
Lambda <- matrix(
data = rnorm(N*4, 0, 1),
nrow = N, ncol = 4
)
#Use Lambda to create B matrix
B <- (Lambda) %*% t(Lambda)
B <- B + 1/10*diag(nrow = nrow(B))
#Turn B into a correlation matrix
W <- diag(B)^(-1/2)*B*diag(B)^(-1/2)
return(W)
}
#########################
##Generate C_hat
#########################
#This builds in the correlation from W into original C_bar
gen_C_hat <- function(){
W <- gen_W()
C_hat <- rep(list(elm), Time + 1)
for (t in 1:(Time+1)) {
C_hat[[t]] <- W %*% C_bar[[t]]
}
return(C_hat)
}
##################################
##Generate final "observed" C
##################################
#This function "observes" characteristics by normalizing them within (-1, 1) via the rank transformation
gen_C <- function(C_matrix){
C <- rep(list(elm), Time+1)
for (t in 1:(Time+1)) {
C[[t]] <- (2/(N*P_c+1))*
matrix(rank(C_matrix[[t]]), nrow = N, ncol = P_c) - matrix(
data = 1, nrow = N, ncol = P_c
)
}
return(C)
}
gen_C <- function(C_matrix){
C <- array(data = 0, dim = c(N, P_c, Time+1))
for (t in 1:(Time+1)) {
C[, , t] <- (2/(N*P_c+1))*
rank(C_matrix[, , t]) - matrix(
data = 1, nrow = N, ncol = P_c
)
}
return(C)
}
C_bar <- gen_C_bar()
C_hat <- gen_C_hat()
###################
##characteristics C_bar
###################
#######
##Function to Generate C_bar
#######
gen_C_bar <- function(){
#Initialize am empty array with i, j, t indexing
C_bar <- array(
data = 0, dim = c(N, P_c, (Time+2))
)
#Generate rho vector to be constant across time and stocks
#Original rho vector in draft proposal
#rho <- runif(P_c, 1/2, 1)
#Lower rho values here will give higher time series correlation, and lower cross sectional r squared
for (t in 1:(Time+1)) {
for (j in 1:P_c) {
C_bar[, j, t+1] <- C_bar[, j, t] * rho[j] + rnorm(N, 0, 1)
}
}
##Delete first period full of zeroes
C_bar <- C_bar[, , -1]
return(C_bar)
}
#######################################
##Generate correlation matrix
#######################################
gen_W <- function(){
#Generate Lambda Matrix first
Lambda <- matrix(
data = rnorm(N*4, 0, 1),
nrow = N, ncol = 4
)
#Use Lambda to create B matrix
B <- (Lambda) %*% t(Lambda)
B <- B + 1/10*diag(nrow = nrow(B))
#Turn B into a correlation matrix
W <- diag(B)^(-1/2)*B*diag(B)^(-1/2)
return(W)
}
#########################
##Generate C_hat
#########################
#This builds in the correlation from W into original C_bar
gen_C_hat <- function(){
W <- gen_W()
C_hat <- array(data = 0, dim = c(N, P_c, Time+1))
for (t in 1:(Time+1)) {
C_hat[, , t] <- W %*% C_bar[, , t]
}
return(C_hat)
}
##################################
##Generate final "observed" C
##################################
#This function "observes" characteristics by normalizing them within (-1, 1) via the rank transformation
gen_C <- function(C_matrix){
C <- array(data = 0, dim = c(N, P_c, Time+1))
for (t in 1:(Time+1)) {
C[, , t] <- (2/(N*P_c+1))*
rank(C_matrix[, , t]) - matrix(
data = 1, nrow = N, ncol = P_c
)
}
return(C)
}
C_bar <- gen_C_bar()
C_hat <- gen_C_hat()
C <- gen_C(C_hat)
summary(C[,,1])
#Default theta, 1x3 dimensions
theta <- matrix(c(0.02, 0.02, 0.02), nrow = 1)
g1 <- function(C, x, i, t, theta){
C[i, 1:3, t] * t(x[t, 3]) %*% t(theta)
}
#test if working
g1(C, xt, 1, 1, theta)
C_bar <- gen_C_bar()
C_hat <- gen_C_hat()
C <- gen_C(C_hat)
########################
##xt set up
########################
########################
##Specify A Matrices
########################
A1 <- matrix(c(
0.95, 0, 0,
0, 0.95, 0,
0, 0, 0.95),
nrow = 3, ncol = 3
)
A2 <- matrix(c(
1, 0, 0.25,
0, 0.95, 0,
0.25, 0, 0.95),
nrow = 3, ncol = 3
)
A3 <- matrix(c(
0.99, 0.2, 0.1,
0.2, 0.90, -0.3,
0.1, -0.3, -0.99),
nrow = 3, ncol = 3
)
###################################
###Function to Generate xt series
###################################
#xt is a multivariate time series with 3 different series
#Generates xt series, gien A matrix specification
gen_xt <- function(A){
xt <- data.frame(x1 = c(0:Time),
x2 = c(0:Time),
x3 = c(0:Time)
)
Axt <- xt
for (i in 1:(Time+1)) {
ut <- rnorm(3, mean = 0, sd = 1)
Axt[1+i,] <- Axt[i,] + ut
}
Axt <- Axt[-1,]
return(Axt)
}
#########################################
##Function to plot xt
#########################################
#Transforms xt series to wide format and plots it
plot_xt <- function(xt){
xt_tidy <- cbind(t = c(1:(Time+1)), xt)
xt_tidy <- xt_tidy %>%
gather(series, value, -t)
ggplot(data = xt_tidy) +
geom_line(aes(x = t, y = value, colour = series))
}
#test if working
g1(C, xt, 1, 1, theta)
########################
##xt set up
########################
########################
##Specify A Matrices
########################
A1 <- matrix(c(
0.95, 0, 0,
0, 0.95, 0,
0, 0, 0.95),
nrow = 3, ncol = 3
)
A2 <- matrix(c(
1, 0, 0.25,
0, 0.95, 0,
0.25, 0, 0.95),
nrow = 3, ncol = 3
)
A3 <- matrix(c(
0.99, 0.2, 0.1,
0.2, 0.90, -0.3,
0.1, -0.3, -0.99),
nrow = 3, ncol = 3
)
###################################
###Function to Generate xt series
###################################
#xt is a multivariate time series with 3 different series
#Generates xt series, gien A matrix specification
gen_xt <- function(A){
xt <- data.frame(x1 = c(0:Time),
x2 = c(0:Time),
x3 = c(0:Time)
)
Axt <- xt
for (i in 1:(Time+1)) {
ut <- rnorm(3, mean = 0, sd = 1)
Axt[1+i,] <- Axt[i,] + ut
}
Axt <- Axt[-1,]
return(Axt)
}
#########################################
##Function to plot xt
#########################################
#Transforms xt series to wide format and plots it
plot_xt <- function(xt){
xt_tidy <- cbind(t = c(1:(Time+1)), xt)
xt_tidy <- xt_tidy %>%
gather(series, value, -t)
ggplot(data = xt_tidy) +
geom_line(aes(x = t, y = value, colour = series))
}
xt <- gen_xt(A1)
#test if working
g1(C, xt, 1, 1, theta)
g1 <- function(C, x, i, t, theta){
C[i, 1:3, t] * t(x[t, 3]) %*% t(theta)
}
#test if working
g1(C, xt, 1, 1, theta)
g1 <- function(C, x, i, t, theta){
C[i, 1:3, t] * t(xt[t, 3]) %*% t(theta)
}
#test if working
g1(C, xt, 1, 1, theta)
#Default theta, 1x3 dimensions
theta <- matrix(c(0.02, 0.02, 0.02), nrow = 1)
g1 <- function(C, x, i, t, theta){
C[i, 1:3, t] * t(xt[t, 3]) %*% t(theta)
}
#test if working
g1(C, xt, 1, 1, theta)
g1 <- function(C, x, i, t, theta){
matrix(c(
C[i, 1, t], C[i, 2, t], C[i, 3, t] * t(x[t, 3])
), nrow = 1) %*% t(theta)
}
#test if working
g1(C, xt, 1, 1, theta)
g2 <- function(C, x, i, t, theta){
matrix(c(
C[i, 1, t]^2,
C[i, 1, t]*C[i, 2, t],
sign(
C[i, 3, t] * t(x[t, 3])
)
), nrow = 1) %*% t(theta)
}
#test if working
g2(C, xt, 1, 1, theta)
############################
##Different g() functions
############################
#Logit function, used in some specified structures
logit <- function(x){
(1 + exp(-x))^(-1)
}
#Remmeber that theta needs to be tuned later. Set up all of the functions as functions of theta
##############################
#g1
##############################
#Default theta, 1x3 dimensions
theta <- matrix(c(0.02, 0.02, 0.02), nrow = 1)
g1 <- function(C, x, i, t, theta){
matrix(c(
C[i, 1, t], C[i, 2, t], C[i, 3, t] * t(x[t, 3])
), nrow = 1) %*% t(theta)
}
#test if working
g1(C, xt, 1, 1, theta)
##############################
#g2
##############################
#Default theta, 1x3 dimensions
theta <- matrix(c(0.04, 0.035, 0.01), nrow = 1)
g2 <- function(C, x, i, t, theta){
matrix(c(
C[[t]][i, 1]^2,
C[[t]][i, 1]*C[[t]][i, 2],
sign(
C[[t]][i, 3] * t(x[t, 3])
)
), nrow = 1) %*% t(theta)
}
#test if working
g2(C, xt, 1, 1, theta)
############################
##Different g() functions
############################
#Logit function, used in some specified structures
logit <- function(x){
(1 + exp(-x))^(-1)
}
#Remmeber that theta needs to be tuned later. Set up all of the functions as functions of theta
##############################
#g1
##############################
#Default theta, 1x3 dimensions
theta <- matrix(c(0.02, 0.02, 0.02), nrow = 1)
g1 <- function(C, x, i, t, theta){
matrix(c(
C[i, 1, t], C[i, 2, t], C[i, 3, t] * t(x[t, 3])
), nrow = 1) %*% t(theta)
}
#test if working
g1(C, xt, 1, 1, theta)
##############################
#g2
##############################
#Default theta, 1x3 dimensions
theta <- matrix(c(0.04, 0.035, 0.01), nrow = 1)
g2 <- function(C, x, i, t, theta){
matrix(c(
C[i, 1, t]^2,
C[i, 1, t]*C[i, 2, t],
sign(
C[i, 3, t] * t(x[t, 3])
)
), nrow = 1) %*% t(theta)
}
#test if working
g2(C, xt, 1, 1, theta)
#############################
#g3
#############################
#Default theta, 1x4 dimensions
theta <- matrix(c(0.04, 0.035, 0.01, 0.01), nrow = 1)
g3 <- function(C, x, i, t, theta){
matrix(
c(
(C[i, 1, t] > 0),
C[i, 2, t]^3,
C[i, 1, t] * C[i, 2, t] * (C[i, 3, t] > 0),
logit(C[i, 3, t])
),
nrow = 1) %*% t(theta)
}
#test if working
g3(C, xt, 1, 1, theta)
#################################
#g4
#Remember that we are supposed to pass C hat through to g4
#################################
#Default theta, 1x3 dimensions
theta <- matrix(c(0.02, 0.02, 0.02), nrow = 1)
g4 <- function(C, x, i, t, theta){
matrix(c(
C[i, 1, t],
C[i, 2, t],
C[i, 3, t]*t(x[t, 3])
), nrow = 1
) %*% t(theta)
}
#test if working
g4(C_hat, xt, 1, 1, theta)
#################################
?matrix
gen_Beta <- function(){
Beta <- C[, 1:3, ]
return(Beta)
}
#Check
gen_Beta()
