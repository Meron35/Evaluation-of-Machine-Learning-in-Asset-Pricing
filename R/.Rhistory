###############################
null_matrix <- matrix(0, nrow = 4*N)
null_list <- list(rep(null_matrix), Time+1)
null_list <- (rep(list(null_matrix)), Time+1)
null_list <- rep(list(null_matrix), Time+1)
z <- rep(list(null_matrix), Time+1)
for (i in 1:Time) {
for (i in 1:N){
z[[t]][i] <- kronecker(t(cbind(c(rep(1, 180)), xt)[t, ]), C[[t]][i, ])
}
}
z <- matrix(0, nrow = 400, ncol = Time)
###############################
##Function to build predictor set for each i individual stock, and each time t
###############################
null_matrix <- matrix(0, nrow = Time, ncol = 4*N)
z <- rep(list(null_matrix), N)
for (i in 1:Time) {
for (i in 1:N){
z[[i]][Time, ] <- t(
kronecker(t(cbind(c(rep(1, 180)), xt)[t, ]), C[[t]][i, ])
)
}
}
View(z)
z[[1]]
z[[26]]
t(
kronecker(t(cbind(c(rep(1, 180)), xt)[1, ]), C[[1]][1, ])
)
###############################
##Function to build predictor set for each i individual stock, and each time t
###############################
null_matrix <- matrix(0, nrow = Time, ncol = 4*P_c)
z <- rep(list(null_matrix), N)
for (i in 1:Time) {
for (i in 1:N){
z[[i]][Time, ] <- t(
kronecker(t(cbind(c(rep(1, 180)), xt)[t, ]), C[[t]][i, ])
)
}
}
View(z)
View(z)
z[[200]]
z[[1]]
for (i in 1:N) {
for (i in 1:Time){
z[[i]][Time, ] <- t(
kronecker(t(cbind(c(rep(1, 180)), xt)[t, ]), C[[t]][i, ])
)
}
}
View(z)
z[[1]]
summary(z[[1]])
xt <- data.frame(x1 = c(0:Time),
x2 = c(0:Time),
x3 = c(0:Time)
)
gen_xt <- function(A, xt){
Axt <- xt
for (i in 1:(Time+1)) {
ut <- rnorm(3, mean = 0, sd = 1)
Axt[1+i,] <- Axt[i,] + ut
}
return(Axt)
}
gen_xt(A1, xt)
Axt <- gen_xt(A1, xt)
View(Axt)
gen_xt <- function(A, xt){
Axt <- xt
for (i in 1:(Time+1)) {
ut <- rnorm(3, mean = 0, sd = 1)
Axt[1+i,] <- Axt[i,] + ut
}
Axt[1,] <- NULL
return(Axt)
}
Axt <- gen_xt(A1, xt)
Axt <- AXT[-1,]
gen_xt <- function(A, xt){
Axt <- xt
for (i in 1:(Time+1)) {
ut <- rnorm(3, mean = 0, sd = 1)
Axt[1+i,] <- Axt[i,] + ut
}
Axt <- AXT[-1,]
return(Axt)
}
Axt <- gen_xt(A1, xt)
gen_xt <- function(A, xt){
Axt <- xt
for (i in 1:(Time+1)) {
ut <- rnorm(3, mean = 0, sd = 1)
Axt[1+i,] <- Axt[i,] + ut
}
Axt <- AxT[-1,]
return(Axt)
}
gen_xt <- function(A, xt){
Axt <- xt
for (i in 1:(Time+1)) {
ut <- rnorm(3, mean = 0, sd = 1)
Axt[1+i,] <- Axt[i,] + ut
}
Axt <- Axt[-1,]
return(Axt)
}
Axt <- gen_xt(A1, xt)
View(Axt)
plot_xt(Axt)
plot_xt <- function(xt){
xt_tidy <- cbind(t = c(1:(Time+1)), xt)
xt_tidy <- xt_tidy %>%
gather(series, value, -t)
ggplot(data = xt_tidy) +
geom_line(aes(x = t, y = value, colour = series))
}
plot_xt(Axt)
############################
##Different g() functions
############################
logit <- function(x){
(1 + exp(-x))^(-1)
}
##############################
#g1
##############################
g1 <- function(C, x, i, t){
theta <- matrix(c(0.02, 0.02, 0.02), ncol = 1)
matrix(c(
C[[t]][i,1], C[[t]][i,2], C[[t]][i,3] * t(x[t, 3])
), nrow = 1) %*% theta
}
#test if working
g1(C, xt, 1, 1)
##############################
#g2
##############################
g2 <- function(C, x, i, t){
theta <- matrix(c(0.04, 0.035, 0.01), ncol = 1)
matrix(c(
C[[t]][i, 1]^2,
C[[t]][i, 1]*C[[t]][i, 2],
sign(
C[[t]][i, 3] * t(x[t, 3])
)
), nrow = 1) %*% theta
}
#test if working
g2(C, xt, 1, 1)
#############################
#g3
#############################
g3 <- function(C, x, i, t){
#Need 4 elements for theta
theta <- matrix(c(0.04, 0.035, 0.01, 0.01), ncol = 1)
matrix(
c(
(C[[t]][i, 1] > 0),
C[[t]][i, 2]^3,
C[[t]][i, 1] * C[[t]][i, 2] * (C[[t]][i, 3] > 0),
logit(C[[t]][i, 3])
),
nrow = 1) %*% theta
}
#test if working
g3(C, xt, 1, 1)
#################################
#g4
#Remember that we are supposed to pass C hat through to g4
#################################
g4 <- function(C, x, i, t){
theta <- matrix(c(0.02, 0.02, 0.02), ncol = 1)
matrix(c(
C[[t]][i, 1],
C[[t]][i, 2],
C[[t]][i, 3]*t(x[t, 3])
), nrow = 1
) %*% theta
}
#test if working
g4(C_hat, xt, 1, 1)
#################################
##########################
##Generate Datasets
##With 3 specifications of A and 4 specifications of g(), there should be 3*4 = 12 different sets of data in total
##########################
###########
##Function to generate Beta, i,t
###########
gen_Beta <- function(){
#Empty Matrix Init
eln <- matrix(0, nrow = N, ncol = 3)
Beta <- rep(list(eln), Time+1)
for (t in 1:(Time+1)) {
Beta[[t]] <- C[[t]][, 1:3]
}
return(Beta)
}
#Check
gen_Beta()
gen_v <- function(){
#Empty Matrix Init
elo <- matrix(0, nrow = 3, ncol = 1)
v <- rep(list(elo), Time+1)
for (t in 1:(Time+1)) {
v[[t]] <- matrix(
data = rnorm(3, 0, 1),
nrow = 3, ncol = 1
)
}
return(v)
}
omega <- -0.736
gamma <- 0.90
w <- sqrt(0.363)
gen_error <- function(){
##Generate Sigma first
##Sigma2 can be negative, check with David
sigma2 <- rep(list(0), Time+1)
sigma2[[1]] <- omega + w
for (t in 1:Time+1) {
sigma2[[t+1]] <- omega + gamma*sigma2[[t]] + w
}
sigma2[[1]] <- NULL
##Generate Errors
error <- rep(
list(
matrix(
0, nrow = N, ncol = 1
)
), Time+1
)
for (t in 1:Time+1){
for (i in 1:N) {
error[[t]][i] <- exp(sqrt(abs(sigma2[[t]]))/2)*rnorm(1, 0, 1)
}
}
return(error)
}
##############################
##Function to generate return series given specification of A and g function
##############################
gen_rt <- function(A, g){
elp <- matrix(0, nrow = N, ncol = 1)
rt <- rep(list(elp), Time+1)
#########################
Axt <- gen_xt(A, xt)
Beta <- gen_Beta()
v <- gen_v()
error <- gen_error()
#########################
for (t in 1:(Time)) {
for (i in 1:N){
rt[[t+1]][i] <- g(C, Axt, i, t) + Beta[[t+1]][i, ] %*% v[[t+1]] + error[[t+1]][i]
}
}
return(rt)
}
##############################
##g1
##############################
rt_A1_g1 <- gen_rt(A1, g1)
rt_A2_g1 <- gen_rt(A2, g1)
rt_A3_g1 <- gen_rt(A3, g1)
##############################
##g2
##############################
rt_A1_g2 <- gen_rt(A1, g2)
rt_A2_g2 <- gen_rt(A2, g2)
rt_A3_g2 <- gen_rt(A3, g2)
##############################
##g3
##############################
rt_A1_g3 <- gen_rt(A1, g3)
rt_A2_g3 <- gen_rt(A2, g3)
rt_A3_g3 <- gen_rt(A3, g3)
##############################
##g4
##############################
rt_A1_g4 <- gen_rt(A1, g4)
rt_A2_g4 <- gen_rt(A2, g4)
rt_A3_g4 <- gen_rt(A3, g4)
View(rt_A1_g1)
View(rt_A1_g1)
View(g1)
View(g1)
View(g1)
View(z)
###############################
##Function to build predictor set for each i individual stock, and each time t
###############################
null_matrix <- matrix(0, nrow = Time, ncol = 4*P_c)
z <- rep(list(null_matrix), N)
for (i in 1:N) {
for (i in 1:Time){
z[[i]][Time, ] <- t(
kronecker(t(cbind(c(rep(1, 180)), xt)[t, ]), C[[t]][i, ])
)
}
}
for (i in 1:N) {
for (i in 1:(Time+1)){
z[[i]][Time, ] <- t(
kronecker(t(cbind(c(rep(1, 180)), xt)[t, ]), C[[t]][i, ])
)
}
}
t(
kronecker(t(cbind(c(rep(1, 180)), xt)[1, ]), C[[1]][1, ])
)
C[[1]][1, ]
###############################
##Function to build predictor set for each i individual stock, and each time t
###############################
null_matrix <- matrix(0, nrow = Time+1, ncol = 4*P_c)
z <- rep(list(null_matrix), N)
for (i in 1:N) {
for (i in 1:(Time+1)){
z[[i]][Time, ] <- t(
kronecker(t(cbind(c(rep(1, 180)), xt)[t, ]), C[[t]][i, ])
)
}
}
t(cbind(c(rep(1, 180)), xt)[1, ])
for (i in 1:N) {
for (i in 1:(Time+1)){
z[[i]][Time, ] <- t(
kronecker(t(cbind(c(rep(1, Time+1)), xt)[t, ]), C[[t]][i, ])
)
}
}
View(z)
z[[1]]
summary(z[[1]])
xt
##############################
##Function to generate return series given specification of A and g function
##############################
gen_rt <- function(A, g){
elp <- matrix(0, nrow = N, ncol = 1)
rt <- rep(list(elp), Time+1)
#########################
Axt <- gen_xt(A, xt)
Beta <- gen_Beta()
v <- gen_v()
error <- gen_error()
#########################
for (t in 1:(Time)) {
for (i in 1:N){
rt[[t+1]][i] <- g(C, Axt, i, t) + Beta[[t+1]][i, ] %*% v[[t+1]] + error[[t+1]][i]
}
}
return(rt)
}
##############################
##Generate Return Series
##############################
##############################
##g1
##############################
rt_A1_g1 <- gen_rt(A1, g1)
rt_A2_g1 <- gen_rt(A2, g1)
rt_A3_g1 <- gen_rt(A3, g1)
##############################
##g2
##############################
rt_A1_g2 <- gen_rt(A1, g2)
rt_A2_g2 <- gen_rt(A2, g2)
rt_A3_g2 <- gen_rt(A3, g2)
##############################
##g3
##############################
rt_A1_g3 <- gen_rt(A1, g3)
rt_A2_g3 <- gen_rt(A2, g3)
rt_A3_g3 <- gen_rt(A3, g3)
##############################
##g4
##############################
rt_A1_g4 <- gen_rt(A1, g4)
rt_A2_g4 <- gen_rt(A2, g4)
rt_A3_g4 <- gen_rt(A3, g4)
gen_xt <- function(A){
xt <- data.frame(x1 = c(0:Time),
x2 = c(0:Time),
x3 = c(0:Time)
)
Axt <- xt
for (i in 1:(Time+1)) {
ut <- rnorm(3, mean = 0, sd = 1)
Axt[1+i,] <- Axt[i,] + ut
}
Axt <- Axt[-1,]
return(Axt)
}
##############################
##Function to generate return series given specification of A and g function
##############################
gen_rt <- function(A, g){
elp <- matrix(0, nrow = N, ncol = 1)
rt <- rep(list(elp), Time+1)
#########################
Axt <- gen_xt(A)
Beta <- gen_Beta()
v <- gen_v()
error <- gen_error()
#########################
for (t in 1:(Time)) {
for (i in 1:N){
rt[[t+1]][i] <- g(C, Axt, i, t) + Beta[[t+1]][i, ] %*% v[[t+1]] + error[[t+1]][i]
}
}
return(rt)
}
gen_xt <- function(A){
xt <- data.frame(x1 = c(0:Time),
x2 = c(0:Time),
x3 = c(0:Time)
)
Axt <- xt
for (i in 1:(Time+1)) {
ut <- rnorm(3, mean = 0, sd = 1)
Axt[1+i,] <- Axt[i,] + ut
}
Axt <- Axt[-1,]
return(Axt)
}
##############################
##Generate Return Series
##############################
##############################
##g1
##############################
rt_A1_g1 <- gen_rt(A1, g1)
rt_A2_g1 <- gen_rt(A2, g1)
rt_A3_g1 <- gen_rt(A3, g1)
##############################
##g2
##############################
rt_A1_g2 <- gen_rt(A1, g2)
rt_A2_g2 <- gen_rt(A2, g2)
rt_A3_g2 <- gen_rt(A3, g2)
##############################
##g3
##############################
rt_A1_g3 <- gen_rt(A1, g3)
rt_A2_g3 <- gen_rt(A2, g3)
rt_A3_g3 <- gen_rt(A3, g3)
##############################
##g4
##############################
rt_A1_g4 <- gen_rt(A1, g4)
rt_A2_g4 <- gen_rt(A2, g4)
rt_A3_g4 <- gen_rt(A3, g4)
for (i in 1:N) {
for (i in 1:(Time+1)){
z[[i]][Time, ] <- t(
kronecker(t(cbind(c(rep(1, Time+1)), gen_xt(A1))[t, ]), C[[t]][i, ])
)
}
}
###############################
##Function to build predictor set for each i individual stock, and each time t
###############################
null_matrix <- matrix(0, nrow = Time+1, ncol = 4*P_c)
z <- rep(list(null_matrix), N)
xt <- gen_xt(A1)
for (i in 1:N) {
for (i in 1:(Time+1)){
z[[i]][Time, ] <- t(
kronecker(t(cbind(c(rep(1, Time+1)), xt)[t, ]), C[[t]][i, ])
)
}
}
View(z)
View(z)
View(xt)
z[[1]]
z[[1]][3:4,]
View(xt)
t(
kronecker(t(cbind(c(rep(1, Time+1)), xt)[1, ]), C[[1]][1, ])
)
z <- rep(list(null_matrix), N)
for (i in 1:N) {
for (i in 1:(Time+1)){
z[[i]][Time, ] <- t(
kronecker(t(cbind(c(rep(1, Time+1)), xt)[t, ]), C[[t]][i, ])
)
}
}
z[[1]][1,]
for (i in 1:N) {
for (t in 1:(Time+1)){
z[[i]][Time, ] <- t(
kronecker(t(cbind(c(rep(1, Time+1)), xt)[t, ]), C[[t]][i, ])
)
}
}
for (i in 1:N) {
for (t in 1:(Time+1)){
z[[i]][t, ] <- t(
kronecker(t(cbind(c(rep(1, Time+1)), xt)[t, ]), C[[t]][i, ])
)
}
}
View(z)
z[[1]]
getOption("max.print")
