Beta_v <- gen_betav(C, v_sd = 0.05)
gen_betav <- function(C, v_sd){
Beta <- C[, 1:3, ]
Beta_v <- array(0, dim = c(N, 1, Time+1))
for (t in 1:(Time+1)) {
v <- matrix(data = rnorm(3,mean=0, sd = v_sd),
nrow = 3,
ncol = 1)
for (i in N) {
Beta_v[i, 1, t] <- Beta[1, , t] %*% v
}
}
return(Beta_v)
}
Beta_v <- gen_betav(C, v_sd = 0.05)
Beta_v[, 1, 1]
gen_betav <- function(C, v_sd){
Beta <- C[, 1:3, ]
Beta_v <- array(0, dim = c(N, 1, Time+1))
for (t in 1:(Time+1)) {
v <- matrix(data = rnorm(3,mean=0, sd = v_sd),
nrow = 3,
ncol = 1)
for (i in N) {
Beta_v[i, 1, t] <- Beta[i, , t] %*% v
}
}
return(Beta_v)
}
Beta_v <- gen_betav(C, v_sd = 0.05)
Beta_v[2, 1, ]
Beta <- C[, 1:3, ]
Beta[1, , 1]
v <- matrix(data = rnorm(3,mean=0, sd = v_sd),
nrow = 3,
ncol = 1)
v
Beta[1, , 1] %*% v
Beta_v[, , 10]
gen_betav <- function(C, v_sd){
Beta <- C[, 1:3, ]
Beta_v <- array(0, dim = c(N, 1, Time+1))
for (t in 1:(Time+1)) {
v <- matrix(data = rnorm(3,mean=0, sd = v_sd),
nrow = 3,
ncol = 1)
for (i in N) {
Beta_v[i, 1, t] <- Beta[i, , t] %*% v
}
}
return(Beta_v)
}
Beta_v <- gen_betav(C, v_sd = 0.05)
Beta_v[, , 19]
Beta_v[20, , 19]
Beta_v[20, ,]
gen_betav <- function(C, v_sd){
Beta <- C[, 1:3, ]
Beta_v <- array(0, dim = c(N, 1, Time+1))
for (t in 1:(Time+1)) {
v <- matrix(data = rnorm(3,mean=0, sd = v_sd),
nrow = 3,
ncol = 1)
for (i in 1:N) {
Beta_v[i, 1, t] <- Beta[i, , t] %*% v
}
}
return(Beta_v)
}
Beta_v <- gen_betav(C, v_sd = 0.05)
gen_error <- function(sv,
#epsilon sd. Note that this is the normal sd in sv case,
#and student t sd in simple case
ep_sd,
#sv parameters
omega, gamma, w){
#Initialize
error <- array(data = 0, dim = c(N, 1, Time+1))
#SV errors
if (sv == 1) {
##Generate Sigma first (only indexed by time)
sigma2 <- rep(0, Time+1)
#Initial sigma2
sigma2[1] <- omega + w
for (t in 1:Time+1) {
sigma2[t+1] <- omega + gamma*sigma2[t] + rnorm(1, 0, w)
}
error <- rep(0, Time+1)
for (t in 1:(Time+1)) {
for (i in 1:N) {
error[i, 1, t] <- exp(sigma2/2) * rnorm(1, 0, ep_sd)
}
}
return(error)
}
#Student t errors
else {
for (t in 1:(Time+1)) {
error[, , t] <- matrix(data = rt(N, df = 5) * sqrt(ep_sd^2 * (5-2)/5), nrow = N)
}
return(error)
}
}
error <- gen_error(sv = 1, 0.05, omega = -0.736, gamma = 0.90, w = sqrt(0.363))
gen_error <- function(sv,
#epsilon sd. Note that this is the normal sd in sv case,
#and student t sd in simple case
ep_sd,
#sv parameters
omega, gamma, w){
#Initialize
error <- array(data = 0, dim = c(N, 1, Time+1))
#SV errors
if (sv == 1) {
##Generate Sigma first (only indexed by time)
sigma2 <- rep(0, Time+1)
#Initial sigma2
sigma2[1] <- omega + w
for (t in 1:Time+1) {
sigma2[t+1] <- omega + gamma*sigma2[t] + rnorm(1, 0, w)
}
error <- rep(0, Time+1)
for (t in 1:(Time+1)) {
for (i in 1:N) {
error[i, 1, t] <- exp(sigma2[t]/2) * rnorm(1, 0, ep_sd)
}
}
return(error)
}
#Student t errors
else {
for (t in 1:(Time+1)) {
error[, , t] <- matrix(data = rt(N, df = 5) * sqrt(ep_sd^2 * (5-2)/5), nrow = N)
}
return(error)
}
}
error <- gen_error(sv = 1, 0.05, omega = -0.736, gamma = 0.90, w = sqrt(0.363))
gen_error <- function(sv,
#epsilon sd. Note that this is the normal sd in sv case,
#and student t sd in simple case
ep_sd,
#sv parameters
omega, gamma, w){
#Initialize
error <- array(data = 0, dim = c(N, 1, Time+1))
#SV errors
if (sv == 1) {
##Generate Sigma first (only indexed by time)
sigma2 <- rep(0, Time+1)
#Initial sigma2
sigma2[1] <- omega + w
for (t in 1:Time+1) {
sigma2[t+1] <- omega + gamma*sigma2[t] + rnorm(1, 0, w)
}
for (t in 1:(Time+1)) {
for (i in 1:N) {
error[i, 1, t] <- exp(sigma2[t]/2) * rnorm(1, 0, ep_sd)
}
}
return(error)
}
#Student t errors
else {
for (t in 1:(Time+1)) {
error[, , t] <- matrix(data = rt(N, df = 5) * sqrt(ep_sd^2 * (5-2)/5), nrow = N)
}
return(error)
}
}
error <- gen_error(sv = 1, 0.05, omega = -0.736, gamma = 0.90, w = sqrt(0.363))
#Non-SV version check
#You'll still need to specify values for omega, gamma and w, they just won't be used
error <- gen_error(sv = 0, 0.05, omega = -0.736, gamma = 0.90, w = sqrt(0.363))
#First strap on a vector of 1 to the xt set
xt_set <- cbind(1, xt)
View(xt_set)
?kronecker
kronecker(xt_set, C[, , 1])
kronecker(xt_set[1], C[, , 1])
xt_set[1]
kronecker(xt_set[,1], C[, , 1])
kronecker(xt_set[,1], C[1, , 1])
#This works, but we're lacking dimnames
kronecker(xt_set[,1], C[1, , 1], make.dimnames = TRUE)
#This works, but we're lacking dimnames
length(kronecker(xt_set[,1], C[1, , 1], make.dimnames = TRUE))
xt_set[,1]
xt_set[1]
xt_set[1,]
#This works, but we're lacking dimnames
kronecker(xt_set[1,], C[1, , 1], make.dimnames = TRUE)
#This works, but we're lacking dimnames
kronecker(t(xt_set[1,]), C[1, , 1], make.dimnames = TRUE)
#This works, but we're lacking dimnames
typeof(kronecker(t(xt_set[1,]), C[1, , 1], make.dimnames = TRUE))
#This works, but we're lacking dimnames
kronecker(t(xt_set[1,]), C[1, , 1], make.dimnames = TRUE)
#This works, dimnames need to be cleaned up back in the function to generate C though
#Pretty enough as it is
#Kronecker in this form returns a double, convert it to something more useful
matrix(kronecker(t(xt_set[1,]), C[1, , 1], make.dimnames = TRUE))
?matrix
#This works, dimnames need to be cleaned up back in the function to generate C though
#Pretty enough as it is
#Kronecker in this form returns a double, convert it to something more useful
kronecker(t(xt_set[1,]), C[1, , 1], make.dimnames = TRUE)
?kronecker
#This works, dimnames need to be cleaned up back in the function to generate C though
#Pretty enough as it is
#Kronecker in this form returns a double, convert it to something more useful
x <- kronecker(t(xt_set[1,]), C[1, , 1], make.dimnames = TRUE)
x[1]
x[2]
dimnames(x)
#This works, dimnames need to be cleaned up back in the function to generate C though
#Pretty enough as it is
#Kronecker will return an array
z1 <- kronecker(t(xt_set[1,]), C[1, , 1], make.dimnames = TRUE)
z2 <- kronecker(t(xt_set[2,]), C[2, , 1], make.dimnames = TRUE)
z1
z2
length(z1)
t(z1)
data.frame(t(z1))
matrix(t(z1))
z1
t(z1)
data.frame(z1)
data.frame(t(z1))
t(z1)
?array
?provideDimnames
###################
##characteristics C_bar
###################
#######
##Function to Generate C_bar
#######
gen_C_bar <- function(){
#Initialize am empty array with i, j, t indexing
C_bar <- array(data = 0, dim = c(N, P_c, (Time+2)))
#Create some dimnames
C_bar <- provideDimnames(C_bar, sep = "_", base = list("stock", "c", "time"))
#Generate rho vector to be constant across time and stocks
#Original rho vector in draft proposal
#rho <- runif(P_c, 1/2, 1)
#Lower rho values here will give higher time series correlation, and lower cross sectional r squared. New rho is just 0.5 across all stocks and all times.
rho <- rep(0.5, P_c)
for (t in 1:(Time+1)) {
for (j in 1:P_c) {
C_bar[, j, t+1] <- C_bar[, j, t] * rho[j] + rnorm(N, 0, 1)
}
}
##Delete first period full of zeroes
C_bar <- C_bar[, , -1]
return(C_bar)
}
#######################################
##Generate correlation matrix
#######################################
gen_W <- function(){
#Generate Lambda Matrix first
Lambda <- matrix(
data = rnorm(N*4, 0, 1),
nrow = N, ncol = 4
)
#Use Lambda to create B matrix
B <- (Lambda) %*% t(Lambda)
B <- B + 1/10*diag(nrow = nrow(B))
#Turn B into a correlation matrix
W <- diag(B)^(-1/2)*B*diag(B)^(-1/2)
return(W)
}
#########################
##Generate C_hat
#########################
#This builds in the correlation from W into original C_bar
#This already calls gen_W and does everything for you, but you need to specify a C_bar
gen_C_hat <- function(C_bar){
W <- gen_W()
C_hat <- array(data = 0, dim = c(N, P_c, Time+1))
for (t in 1:(Time+1)) {
C_hat[, , t] <- W %*% C_bar[, , t]
}
return(C_hat)
}
##################################
##Generate final "observed" C
##################################
#This function "observes" characteristics by normalizing them within (-1, 1) via the rank transformation
#Takes any sort of C matrix and normalizes them via rank trasnformation
gen_C <- function(C_matrix){
C <- array(data = 0, dim = c(N, P_c, Time+1))
for (t in 1:(Time+1)) {
C[, , t] <- (2/(N*P_c+1))*
rank(C_matrix[, , t]) - matrix(
data = 1, nrow = N, ncol = P_c
)
}
return(C)
}
C_bar <- gen_C_bar()
c_bar[, , 1]
C_bar[, , 1]
gen_C_bar <- function(){
#Initialize am empty array with i, j, t indexing
C_bar <- array(data = 0, dim = c(N, P_c, (Time+2)))
#Create some dimnames
C_bar <- provideDimnames(C_bar, sep = "_", base = list("stock", "c", "time"), unique = true)
#Generate rho vector to be constant across time and stocks
#Original rho vector in draft proposal
#rho <- runif(P_c, 1/2, 1)
#Lower rho values here will give higher time series correlation, and lower cross sectional r squared. New rho is just 0.5 across all stocks and all times.
rho <- rep(0.5, P_c)
for (t in 1:(Time+1)) {
for (j in 1:P_c) {
C_bar[, j, t+1] <- C_bar[, j, t] * rho[j] + rnorm(N, 0, 1)
}
}
##Delete first period full of zeroes
C_bar <- C_bar[, , -1]
return(C_bar)
}
C_bar <- gen_C_bar()
C_bar <- provideDimnames(C_bar, sep = "_", base = list("stock", "c", "time"), unique = TRUE)
gen_C_bar <- function(){
#Initialize am empty array with i, j, t indexing
C_bar <- array(data = 0, dim = c(N, P_c, (Time+2)))
#Create some dimnames
C_bar <- provideDimnames(C_bar, sep = "_", base = list("stock", "c", "time"), unique = TRUE)
#Generate rho vector to be constant across time and stocks
#Original rho vector in draft proposal
#rho <- runif(P_c, 1/2, 1)
#Lower rho values here will give higher time series correlation, and lower cross sectional r squared. New rho is just 0.5 across all stocks and all times.
rho <- rep(0.5, P_c)
for (t in 1:(Time+1)) {
for (j in 1:P_c) {
C_bar[, j, t+1] <- C_bar[, j, t] * rho[j] + rnorm(N, 0, 1)
}
}
##Delete first period full of zeroes
C_bar <- C_bar[, , -1]
return(C_bar)
}
C_bar <- gen_C_bar()
C_bar
?paste
(nth <- paste0(1:12, c("st", "nd", "rd", rep("th", 9))))
nth
paste0(stock_, c(1:N))
paste0("stock_", c(1:N))
list(paste0("stock_", c(1:N)))
?array
gen_C_bar <- function(){
#Create some dimnames
#provideDimnames doesn't do exactly what I want it to
#Just do it manually via paste0
stock_dim <- paste0("stock_", c(1:N))
c_dim <- paste0("c_", c(1:P_c))
time_dim <- paste0("time_", c(1:(Time+1)))
#Initialize am empty array with i, j, t indexing
C_bar <- array(data = 0, dim = c(N, P_c, (Time+2)), dimnames = list(stock_dim, c_dim, time_dim))
#Generate rho vector to be constant across time and stocks
#Original rho vector in draft proposal
#rho <- runif(P_c, 1/2, 1)
#Lower rho values here will give higher time series correlation, and lower cross sectional r squared. New rho is just 0.5 across all stocks and all times.
rho <- rep(0.5, P_c)
for (t in 1:(Time+1)) {
for (j in 1:P_c) {
C_bar[, j, t+1] <- C_bar[, j, t] * rho[j] + rnorm(N, 0, 1)
}
}
##Delete first period full of zeroes
C_bar <- C_bar[, , -1]
return(C_bar)
}
C_bar <- gen_C_bar()
list(stock_dim, c_dim, time_dim)
stock_dim <- paste0("stock_", c(1:N))
c_dim <- paste0("c_", c(1:P_c))
time_dim <- paste0("time_", c(1:(Time+1)))
list(stock_dim, c_dim, time_dim)
dimnames(C_bar)
dimnames(C_bar)
dimnames(C_bar)[1]
dimnames(C_bar)[[1]]
dimnames(C_bar)[[1]] <- stock_dim
dimnames(C_bar)[[1]]
gen_C_bar <- function(){
#Initialize am empty array with i, j, t indexing
C_bar <- array(data = 0, dim = c(N, P_c, (Time+2)))
#Create some dimnames
#provideDimnames doesn't do exactly what I want it to
#Just do it manually via paste0
stock_dim <- paste0("stock_", c(1:N))
c_dim <- paste0("c_", c(1:P_c))
time_dim <- paste0("time_", c(1:(Time+1)))
dimnames(C_bar)[[1]] <- stock_dim
dimnames(C_bar)[[2]] <- c_dim
dimnames(C_bar)[[3]] <- time_dim
#Generate rho vector to be constant across time and stocks
#Original rho vector in draft proposal
#rho <- runif(P_c, 1/2, 1)
#Lower rho values here will give higher time series correlation, and lower cross sectional r squared. New rho is just 0.5 across all stocks and all times.
rho <- rep(0.5, P_c)
for (t in 1:(Time+1)) {
for (j in 1:P_c) {
C_bar[, j, t+1] <- C_bar[, j, t] * rho[j] + rnorm(N, 0, 1)
}
}
##Delete first period full of zeroes
C_bar <- C_bar[, , -1]
return(C_bar)
}
C_bar <- gen_C_bar()
gen_C_bar <- function(){
#Create some dimnames
#provideDimnames doesn't do exactly what I want it to
#Just do it manually via paste0
stock_dim <- paste0("stock_", c(1:N))
c_dim <- paste0("c_", c(1:P_c))
time_dim <- paste0("time_", c(1:(Time+2)))
#Initialize am empty array with i, j, t indexing
C_bar <- array(data = 0, dim = c(N, P_c, (Time+2)), dimnames = list(stock_dim, c_dim, time_dim))
#Generate rho vector to be constant across time and stocks
#Original rho vector in draft proposal
#rho <- runif(P_c, 1/2, 1)
#Lower rho values here will give higher time series correlation, and lower cross sectional r squared. New rho is just 0.5 across all stocks and all times.
rho <- rep(0.5, P_c)
for (t in 1:(Time+1)) {
for (j in 1:P_c) {
C_bar[, j, t+1] <- C_bar[, j, t] * rho[j] + rnorm(N, 0, 1)
}
}
##Delete first period full of zeroes
C_bar <- C_bar[, , -1]
return(C_bar)
}
C_bar <- gen_C_bar()
dimnames(C_bar)
gen_C_bar <- function(){
#Create some dimnames
#provideDimnames doesn't do exactly what I want it to
#Just do it manually via paste0
stock_dim <- paste0("stock_", c(1:N))
c_dim <- paste0("c_", c(1:P_c))
time_dim <- paste0("time_", c(0:(Time+1)))
#Initialize am empty array with i, j, t indexing
C_bar <- array(data = 0, dim = c(N, P_c, (Time+2)), dimnames = list(stock_dim, c_dim, time_dim))
#Generate rho vector to be constant across time and stocks
#Original rho vector in draft proposal
#rho <- runif(P_c, 1/2, 1)
#Lower rho values here will give higher time series correlation, and lower cross sectional r squared. New rho is just 0.5 across all stocks and all times.
rho <- rep(0.5, P_c)
for (t in 1:(Time+1)) {
for (j in 1:P_c) {
C_bar[, j, t+1] <- C_bar[, j, t] * rho[j] + rnorm(N, 0, 1)
}
}
##Delete first period full of zeroes
C_bar <- C_bar[, , -1]
return(C_bar)
}
C_bar <- gen_C_bar()
dimnames(C_bar)
C_hat <- gen_C_hat(C_bar)
dimnames(C_hat)
gen_C_hat <- function(C_bar){
W <- gen_W()
stock_dim <- paste0("stock_", c(1:N))
c_dim <- paste0("c_", c(1:P_c))
time_dim <- paste0("time_", c(1:(Time+1)))
C_hat <- array(data = 0, dim = c(N, P_c, Time+1), dimnames = list(stock_dim, c_dim, time_dim))
for (t in 1:(Time+1)) {
C_hat[, , t] <- W %*% C_bar[, , t]
}
return(C_hat)
}
C_hat <- gen_C_hat(C_bar)
dimnames(C_hat)
gen_C <- function(C_matrix){
stock_dim <- paste0("stock_", c(1:N))
c_dim <- paste0("c_", c(1:P_c))
time_dim <- paste0("time_", c(1:(Time+1)))
C <- array(data = 0, dim = c(N, P_c, Time+1), dimnames = list(stock_dim, c_dim, time_dim))
for (t in 1:(Time+1)) {
C[, , t] <- (2/(N*P_c+1))*
rank(C_matrix[, , t]) - matrix(
data = 1, nrow = N, ncol = P_c
)
}
return(C)
}
C <- gen_C(C_hat)
dimnames(C)
#This works, dimnames need to be cleaned up back in the function to generate C though
#Pretty enough as it is
#Kronecker will return an array
z1 <- kronecker(t(xt_set[1,]), C[1, , 1], make.dimnames = TRUE)
z1
dimnames(xt_set)
dimnames(xt_set[1,])
xt_set[1,]
xt_set
dimnames(xt_set[1,])[[1]] <- NULL
xt_set
View(xt_set)
typeof(xt_set)
typeof(xt_set)
View(xt)
dimnames(xt)
