data = rnorm(3, 0, v_sd),
nrow = 3, ncol = 1
)
}
return(v)
}
#No SV error strucure for Gu et al, yay!
###
##Epsilon Term is N x 1 vector of idiosyncatic errors, distributed at students t with 5 dof (0, 0.05^2)
###
ep_sd <- 0.05
gu_gen_error <- function(ep_sd){
error <- rep(
list(
matrix(
0, nrow = N, ncol = 1
)
), Time+1
)
for (t in 1:Time+1){
for (i in 1:N) {
#This is how you build in a specified variance for student t
error[[t]][i] <- rt(1, 5)*sqrt(ep_sd^2 * (5-2)/5)
}
}
return(error)
}
############################################################################
##Function to generate return series + its residuals given specification of g function
############################################################################
gu_gen_rt_resid <- function(v_sd, ep_sd){
elp <- matrix(0, nrow = N, ncol = 1)
resid <- rep(list(elp), Time+1)
##############################
Beta <- gen_Beta(C)
v <- gu_gen_v(v_sd)
error <- gu_gen_error(ep_sd)
##############################
for (t in 1:(Time)) {
for (i in 1:N){
resid[[t+1]][i] <- Beta[[t+1]][i, ] %*% v[[t+1]] + error[[t+1]][i]
}
}
return(resid)
}
gu_gen_g <- function(g){
elp <- matrix(0, nrow = N, ncol = 1)
rt <- rep(list(elp), Time+1)
#########################
gu_xt <- gen_gu_xt()
#########################
for (t in 1:(Time)) {
for (i in 1:N){
rt[[t+1]][i] <- g(C, gu_xt, i, t, theta)
}
}
return(rt)
}
############################################################################
##Function to generate return series + its residuals given specification of g function
############################################################################
gu_gen_rt_resid <- function(v_sd, ep_sd){
elp <- matrix(0, nrow = N, ncol = 1)
resid <- rep(list(elp), Time+1)
##############################
Beta <- gen_Beta(C)
v <- gu_gen_v(v_sd)
error <- gu_gen_error(ep_sd)
##############################
for (t in 1:(Time)) {
for (i in 1:N){
resid[[t+1]][i] <- Beta[[t+1]][i, ] %*% v[[t+1]] + error[[t+1]][i]
}
}
return(resid)
}
gu_gen_g <- function(g){
elp <- matrix(0, nrow = N, ncol = 1)
rt <- rep(list(elp), Time+1)
#########################
gu_xt <- gu_gen_xt()
#########################
for (t in 1:(Time)) {
for (i in 1:N){
rt[[t+1]][i] <- g(C, gu_xt, i, t, theta)
}
}
return(rt)
}
#Tuning Cross Sectional R Squared SKELETON CODE
#We want inidividual r squared for each stock to be 50%
#We want inidividual annualized volatility to be 30%
#We want to cross sectional R squared to be 25%
#We want the predictive R squared to be 5%
#Generate paramaters first
#Tune v_sd for inidividual r square first
#Gu et al had 0.05 for their v sd
v_sd <- 0.05
ep_sd <- 0.05
#Tune theta for cross sectional r square
#theta
theta <- matrix(c(0.02, 0.02, 0.02), nrow = 1)
resid <- gu_gen_rt_resid(v_sd, ep_sd)
g <- gu_gen_g(gu_g1)
rt_cross_tune_panel <- data.frame(
g = rep(0, N*Time),
resid = rep(0, N*Time),
time = rep(0, N*Time),
stock = rep(0, N*Time)
)
for (i in 1:N){
rt_cross_tune_df <- data.frame(
resid = rep(0, Time+1),
g = rep(0, Time+1),
time = rep(0, Time+1),
stock = rep(i, Time+1)
)
for (t in 1:(Time+1)){
rt_cross_tune_df$resid[t] <- resid[[t]][i]
rt_cross_tune_df$g[t] <- g[[t]][i]
rt_cross_tune_df$time <- t
}
#Cbind returns, id, time and predictors
rt_cross_tune_panel[((i-1)*(Time+1)+1):(i*(Time+1)), ] <- rt_cross_tune_df
}
#Remove 1st row because returns data only starts from t = 2
rt_cross_tune_panel <- rt_cross_tune_panel %>%
filter(time != 1) %>%
select(-time) %>%
mutate(return = resid + g)
#Individual return R squared
rt_id_tune_df <- data.frame(
stock = c(1:N),
rsquare = c(1:N)
)
for (i in 1:N) {
rt_id_tune_panel <- rt_cross_tune_panel %>%
filter(stock == i)
SSR <- t(rt_id_tune_panel$return - rt_id_tune_panel$g) %*% (rt_id_tune_panel$return - rt_id_tune_panel$g)
SST <- t(rt_id_tune_panel$return - mean(rt_id_tune_panel$return)) %*% (rt_id_tune_panel$return - mean(rt_id_tune_panel$return))
#SST <- t(rt_id_tune_panel$return) %*% (rt_id_tune_panel$return)
rt_id_tune_df$rsquare[i] <- 1 - SSR/SST
}
#Sanity check
summary((rt_id_tune_panel$return - rt_id_tune_panel$g) - rt_id_tune_panel$resid)
#Makes sure that the right returns, residuals etc are lined up correctly
#Looks good (not exactly zero due to rounding)
#Return mean of each individual rsquared
mean(rt_id_tune_df$rsquare)
#Calculate Annualized Volatility
#Annualized volatility = calculate volatility (via standard deviation) for the monthly returns, then annualize it by multiplying it by sqrt(12) for 12 months in a year
vol_tune_df <- data.frame(
stock = c(1:N),
annual_vol = c(1:N)
)
for (i in 1:N) {
vol_tune_panel <- rt_cross_tune_panel %>%
filter(stock == i)
vol_tune_df$annual_vol[i] <- sd(vol_tune_panel$return) * sqrt(12)
}
#Return the mean annualized volatility
#Want this aorund 30%
mean(vol_tune_df$annual_vol)
#Cross sectional r squared
SSR <- t(rt_cross_tune_panel$resid) %*% (rt_cross_tune_panel$resid)
SST <- t(rt_cross_tune_panel$return - mean(rt_cross_tune_panel$return)) %*% (rt_cross_tune_panel$return - mean(rt_cross_tune_panel$return))
#SST <- t(rt_cross_tune_panel$return) %*% (rt_cross_tune_panel$return)
1 - SSR/SST
#This is quite off from Gu et al's specification and results. NOT GOOD
df <- data.frame(matrix(unlist(resid), nrow=length(resid), byrow=T))
View(df)
df <- data.frame(matrix(unlist(g), nrow=length(g), byrow=T))
View(df)
?kronecker
a <- data.frame(x = c(1:4), y = c(1:4))
b <- data.frame(z = c(1:4), t = c(1:4))
kronecker(a, b)
a <- data.frame(x = c(1:4))
b <- data.frame(z = c(1:4))
kronecker(a, b)
kronecker(a, b, make.dimnames = T)
fred <- matrix(1:12, 3, 4, dimnames = list(LETTERS[1:3], LETTERS[4:7]))
bill <- c("happy" = 100, "sad" = 1000)
kronecker(fred, bill, make.dimnames = TRUE)
bill <- outer(bill, c("cat" = 3, "dog" = 4))
kronecker(fred, bill, make.dimnames = TRUE)
elm <- matrix(data = 0, nrow = Time+1, ncol = P_c+1)
#####################################
##Simulation
#####################################
#The defaults are N = 200, P_c = 50 or 100
#Keeping this low for now just to make everything more manageable
#Number of stocks
N <- 20
#Number of characteristics that underly true model
P_c <- 10
#Number of Periods
Time <- 180
elm <- matrix(data = 0, nrow = Time+1, ncol = P_c+1)
characteristics <- matrix(0, ncol = P_c)
?matrix
?data.frame
characteristics <- data.frame(matrix(0, ncol = P_c))
View(characteristics)
elm <- cbind(elm, characteristics)
View(elm)
elm <- data.frame(time = c(1:(Time+1)), stock = 1)
elm <- cbind(elm, characteristics)
View(elm)
characteristics <- data.frame(time = c(1:(Time+1), matrix(0, ncol = P_c))
View(characteristics)
View(characteristics)
characteristics <- data.frame(time = c(1:(Time+1), matrix(0, ncol = P_c)))
View(characteristics)
characteristics <- data.frame(matrix(0, ncol = P_c, nrow = (Time+1)))
View(characteristics)
runif(10) * rnorm(10)
?runif
characteristics <- data.frame(matrix(0, ncol = P_c, nrow = (Time+1)))
for (t in 1:(Time+1)) {
characteristics[t] <- characteristics[t-1]*runif(P_c, 0.9, 1) + rnorm(P_c, 0, 1)
}
View(characteristics)
characteristics[1]*runif(P_c, 0.9, 1)
?outer
gen_C_bar <- function(){
#empty matrix
elm <- matrix(
data = 0, nrow = N, ncol = P_c
)
C_bar <- rep(list(elm), Time + 2)
#Gu et al set rho to runif 0.9, 1
#Generate a rho different across j, but constant across t and i
rho <- runif(P_c, 0.9, 1)
for (t in 1:(Time+1)) {
for (j in 1:P_c) {
#Gu et al set error term here to be standard normal
C_bar[[t+1]][, j] <- (C_bar[[t]][, j]*rho[j] + rnorm(N, 0, 1))
}
}
##Delete first period full of zeroes
C_bar[[1]] <- NULL
return(C_bar)
}
###################
##characteristics C_bar
###################
#######
##Function to Generate C_bar
#######
#Gu et al's specification does has a constant rho for all t and i, but differs across j
gen_C_bar <- function(){
#empty matrix
elm <- matrix(
data = 0, nrow = N, ncol = P_c
)
C_bar <- rep(list(elm), Time + 2)
#Gu et al set rho to runif 0.9, 1
#Generate a rho different across j, but constant across t and i
rho <- runif(P_c, 0.9, 1)
for (t in 1:(Time+1)) {
for (j in 1:P_c) {
#Gu et al set error term here to be standard normal
C_bar[[t+1]][, j] <- (C_bar[[t]][, j]*rho[j] + rnorm(N, 0, 1))
}
}
##Delete first period full of zeroes
C_bar[[1]] <- NULL
return(C_bar)
}
##################################
##Generate final "observed" C
##################################
#Remember you need to generate C_bar and C_hat first
#This function "observes" characteristics by normalizing them within (-1, 1) via the rank transformation
gen_C <- function(C_matrix){
elm <- matrix(
data = 0, nrow = N, ncol = P_c
)
C <- rep(list(elm), Time+1)
for (t in 1:(Time+1)) {
C[[t]] <- (2/(N*P_c+1))*
matrix(rank(C_matrix[[t]]), nrow = N, ncol = P_c) - matrix(
data = 1, nrow = N, ncol = P_c
)
}
return(C)
}
C_bar <- gen_C_bar()
#C_hat <- gen_C_hat()
#Gu et al do NOT build in cross sectional correlation
C <- gen_C(C_bar)
View(C)
View(C)
C[[1]]
View(C_bar)
View(C_bar)
###########################################
## GU ET AL UNIVARIATE SPECIFICATION
###########################################
gu_gen_xt <- function(){
xt <- c(0:Time)
p <- 0.95
for (i in 1:(Time+1)) {
#Gu et al set these to N(0, 1-p^2); p^2 = 0.95
ut <- rnorm(1, mean = 0, sd = (1-p^2))
xt[1+i] <- p*xt[i] + ut
}
#Remove Initial
xt <- xt[-1]
return(xt)
}
#Test, working
gu_xt <- gu_gen_xt()
acf(gu_xt)
#######################
#g1
#######################
#Default theta, 1x3 dimensions
theta <- matrix(c(0.02, 0.02, 0.02), nrow = 1)
gu_g1 <- function(C, x, i, t, theta){
matrix(c(
C[[t]][i,1], C[[t]][i,2], C[[t]][i,3] * x[t]
), nrow = 1) %*% t(theta)
}
#test if working, working
gu_g1(C, gu_xt, 1, 1, theta)
#######################
#g2
#######################
#Default theta, 1x3 dimensions
theta <- matrix(c(0.04, 0.035, 0.01), nrow = 1)
gu_g2 <- function(C, x, i, t, theta){
matrix(c(
C[[t]][i, 1]^2,
C[[t]][i, 1]*C[[t]][i, 2],
sign(
C[[t]][i, 3] * x[t]
)
), nrow = 1) %*% t(theta)
}
#test if working
gu_g2(C, gu_xt, 1, 1, theta)
#Both Working, Hooray
##########################
##Functions for elements in return equation
##########################
###########
##Function to generate Beta, i,t
###########
#Beta is the the first 3 rows of the specified characteristics vector
gen_Beta <- function(C){
#Empty Matrix Init
eln <- matrix(0, nrow = N, ncol = 3)
Beta <- rep(list(eln), Time+1)
for (t in 1:(Time+1)) {
Beta[[t]] <- C[[t]][, 1:3]
}
return(Beta)
}
#Check
Beta <- gen_Beta(C)
###
##v error term
###
#This is is trivariate N(0, 0.05^2) series, constant across all stocks
v_sd <- 0.05
gu_gen_v <- function(v_sd){
#Empty Matrix Init
elo <- matrix(0, nrow = 3, ncol = 1)
v <- rep(list(elo), Time+1)
for (t in 1:(Time+1)) {
v[[t]] <- matrix(
data = rnorm(3, 0, v_sd),
nrow = 3, ncol = 1
)
}
return(v)
}
#No SV error strucure for Gu et al, yay!
###
##Epsilon Term is N x 1 vector of idiosyncatic errors, distributed at students t with 5 dof (0, 0.05^2)
###
ep_sd <- 0.05
gu_gen_error <- function(ep_sd){
error <- rep(
list(
matrix(
0, nrow = N, ncol = 1
)
), Time+1
)
for (t in 1:Time+1){
for (i in 1:N) {
#This is how you build in a specified variance for student t
error[[t]][i] <- rt(1, 5)*sqrt(ep_sd^2 * (5-2)/5)
}
}
return(error)
}
############################################################################
##Function to generate return series + its residuals given specification of g function
############################################################################
gu_gen_rt_resid <- function(v_sd, ep_sd){
elp <- matrix(0, nrow = N, ncol = 1)
resid <- rep(list(elp), Time+1)
##############################
Beta <- gen_Beta(C)
v <- gu_gen_v(v_sd)
error <- gu_gen_error(ep_sd)
##############################
for (t in 1:(Time)) {
for (i in 1:N){
resid[[t+1]][i] <- Beta[[t+1]][i, ] %*% v[[t+1]] + error[[t+1]][i]
}
}
return(resid)
}
gu_gen_g <- function(g){
elp <- matrix(0, nrow = N, ncol = 1)
rt <- rep(list(elp), Time+1)
#########################
gu_xt <- gu_gen_xt()
#########################
for (t in 1:(Time)) {
for (i in 1:N){
rt[[t+1]][i] <- g(C, gu_xt, i, t, theta)
}
}
return(rt)
}
#Tuning Cross Sectional R Squared SKELETON CODE
#We want inidividual r squared for each stock to be 50%
#We want inidividual annualized volatility to be 30%
#We want to cross sectional R squared to be 25%
#We want the predictive R squared to be 5%
#Generate paramaters first
#Tune v_sd for inidividual r square first
#Gu et al had 0.05 for their v sd
v_sd <- 0.05
ep_sd <- 0.05
#Tune theta for cross sectional r square
#theta
theta <- matrix(c(0.02, 0.02, 0.02), nrow = 1)
resid <- gu_gen_rt_resid(v_sd, ep_sd)
g <- gu_gen_g(gu_g1)
rt_cross_tune_panel <- data.frame(
g = rep(0, N*Time),
resid = rep(0, N*Time),
time = rep(0, N*Time),
stock = rep(0, N*Time)
)
for (i in 1:N){
rt_cross_tune_df <- data.frame(
resid = rep(0, Time+1),
g = rep(0, Time+1),
time = rep(0, Time+1),
stock = rep(i, Time+1)
)
for (t in 1:(Time+1)){
rt_cross_tune_df$resid[t] <- resid[[t]][i]
rt_cross_tune_df$g[t] <- g[[t]][i]
rt_cross_tune_df$time <- t
}
#Cbind returns, id, time and predictors
rt_cross_tune_panel[((i-1)*(Time+1)+1):(i*(Time+1)), ] <- rt_cross_tune_df
}
df <- data.frame(matrix(unlist(g), nrow=length(g), byrow=T))
#Remove 1st row because returns data only starts from t = 2
rt_cross_tune_panel <- rt_cross_tune_panel %>%
filter(time != 1) %>%
select(-time) %>%
mutate(return = resid + g)
#Individual return R squared
rt_id_tune_df <- data.frame(
stock = c(1:N),
rsquare = c(1:N)
)
for (i in 1:N) {
rt_id_tune_panel <- rt_cross_tune_panel %>%
filter(stock == i)
SSR <- t(rt_id_tune_panel$return - rt_id_tune_panel$g) %*% (rt_id_tune_panel$return - rt_id_tune_panel$g)
SST <- t(rt_id_tune_panel$return - mean(rt_id_tune_panel$return)) %*% (rt_id_tune_panel$return - mean(rt_id_tune_panel$return))
#SST <- t(rt_id_tune_panel$return) %*% (rt_id_tune_panel$return)
rt_id_tune_df$rsquare[i] <- 1 - SSR/SST
}
#Sanity check
summary((rt_id_tune_panel$return - rt_id_tune_panel$g) - rt_id_tune_panel$resid)
#Makes sure that the right returns, residuals etc are lined up correctly
#Looks good (not exactly zero due to rounding)
#Return mean of each individual rsquared
mean(rt_id_tune_df$rsquare)
#Calculate Annualized Volatility
#Annualized volatility = calculate volatility (via standard deviation) for the monthly returns, then annualize it by multiplying it by sqrt(12) for 12 months in a year
vol_tune_df <- data.frame(
stock = c(1:N),
annual_vol = c(1:N)
)
for (i in 1:N) {
vol_tune_panel <- rt_cross_tune_panel %>%
filter(stock == i)
vol_tune_df$annual_vol[i] <- sd(vol_tune_panel$return) * sqrt(12)
}
#Return the mean annualized volatility
#Want this aorund 30%
mean(vol_tune_df$annual_vol)
#Cross sectional r squared
SSR <- t(rt_cross_tune_panel$resid) %*% (rt_cross_tune_panel$resid)
SST <- t(rt_cross_tune_panel$return - mean(rt_cross_tune_panel$return)) %*% (rt_cross_tune_panel$return - mean(rt_cross_tune_panel$return))
#SST <- t(rt_cross_tune_panel$return) %*% (rt_cross_tune_panel$return)
1 - SSR/SST
#This is quite off from Gu et al's specification and results. NOT GOOD
